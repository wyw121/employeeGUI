use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use tauri::command;
use tracing::{error, info};

#[cfg(windows)]
use std::os::windows::process::CommandExt;

// ==================== æ™ºèƒ½æ“ä½œç±»å‹ ====================

/// å¢å¼ºçš„æ“ä½œç±»å‹ï¼Œæ”¯æŒæ™ºèƒ½è¯†åˆ«å’ŒéªŒè¯
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SmartActionType {
    // åŸºç¡€æ“ä½œ
    Tap,
    Swipe,
    Input,
    Wait,
    
    // æ™ºèƒ½æ“ä½œ
    SmartTap,           // æ™ºèƒ½ç‚¹å‡»ï¼Œæ”¯æŒåŠ¨æ€åæ ‡è¯†åˆ«
    SmartFindElement,   // æ™ºèƒ½å…ƒç´ æŸ¥æ‰¾
    RecognizePage,      // é¡µé¢çŠ¶æ€è¯†åˆ«
    VerifyAction,       // æ“ä½œç»“æœéªŒè¯
    SmartLoop,          // æ™ºèƒ½å¾ªç¯
    ConditionalAction,  // æ¡ä»¶æ“ä½œ
    WaitForPageState,   // ç­‰å¾…é¡µé¢çŠ¶æ€
    ExtractElement,     // æå–UIå…ƒç´ ä¿¡æ¯
    SmartNavigation,    // æ™ºèƒ½å¯¼èˆª
    
    // å¤åˆæ“ä½œ
    CompleteWorkflow,   // å®Œæ•´å·¥ä½œæµç¨‹
}

// ==================== é¡µé¢çŠ¶æ€ç³»ç»Ÿ ====================

/// é€šç”¨é¡µé¢çŠ¶æ€æšä¸¾
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum PageState {
    Unknown,
    Home,
    AppMainPage,
    Loading,
    Dialog,
    Settings,
    ListPage,
    DetailPage,
    Custom(String),     // è‡ªå®šä¹‰é¡µé¢çŠ¶æ€
}

/// é¡µé¢è¯†åˆ«ç»“æœ
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PageRecognitionResult {
    pub current_state: PageState,
    pub confidence: f32,
    pub key_elements: Vec<String>,
    pub ui_elements: Vec<SmartUIElement>,
    pub message: String,
    pub timestamp: String,
}

// ==================== UIå…ƒç´ ç³»ç»Ÿ ====================

/// æ™ºèƒ½UIå…ƒç´ 
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SmartUIElement {
    pub element_type: UIElementType,
    pub text: String,
    pub bounds: (i32, i32, i32, i32), // (left, top, right, bottom)
    pub center: (i32, i32),           // ä¸­å¿ƒç‚¹åæ ‡
    pub clickable: bool,
    pub visible: bool,
    pub resource_id: Option<String>,
    pub class_name: Option<String>,
    pub content_desc: Option<String>,
    pub package: Option<String>,
}

/// UIå…ƒç´ ç±»å‹
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum UIElementType {
    Button,
    TextView,
    EditText,
    ImageView,
    ListView,
    ScrollView,
    LinearLayout,
    RelativeLayout,
    FrameLayout,
    Unknown,
}

// ==================== æŸ¥æ‰¾æ¡ä»¶ç³»ç»Ÿ ====================

/// å…ƒç´ æŸ¥æ‰¾æ¡ä»¶
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ElementFindCondition {
    pub text_contains: Option<String>,
    pub text_equals: Option<String>,
    pub text_regex: Option<String>,
    pub resource_id: Option<String>,
    pub class_name: Option<String>,
    pub content_desc: Option<String>,
    pub clickable: Option<bool>,
    pub visible: Option<bool>,
    pub bounds_filter: Option<BoundsFilter>,
    pub element_type: Option<UIElementType>,
}

/// åæ ‡èŒƒå›´è¿‡æ»¤å™¨
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BoundsFilter {
    pub min_x: Option<i32>,
    pub max_x: Option<i32>,
    pub min_y: Option<i32>,
    pub max_y: Option<i32>,
    pub min_width: Option<i32>,
    pub max_width: Option<i32>,
    pub min_height: Option<i32>,
    pub max_height: Option<i32>,
}

// ==================== éªŒè¯æ¡ä»¶ç³»ç»Ÿ ====================

/// æ“ä½œéªŒè¯æ¡ä»¶
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VerificationCondition {
    pub verify_type: VerificationType,
    pub expected_result: String,
    pub timeout_ms: u64,
    pub retry_count: u32,
    pub retry_interval_ms: u64,
}

/// éªŒè¯ç±»å‹
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum VerificationType {
    TextChange,          // æ–‡æœ¬å˜åŒ–éªŒè¯
    PageStateChange,     // é¡µé¢çŠ¶æ€å˜åŒ–
    ElementExists,       // å…ƒç´ å­˜åœ¨æ€§éªŒè¯
    ElementDisappears,   // å…ƒç´ æ¶ˆå¤±éªŒè¯
    ElementTextEquals,   // å…ƒç´ æ–‡æœ¬ç­‰äº
    ElementTextContains, // å…ƒç´ æ–‡æœ¬åŒ…å«
    Custom(String),      // è‡ªå®šä¹‰éªŒè¯é€»è¾‘
}

// ==================== æ™ºèƒ½è„šæœ¬æ­¥éª¤ ====================

/// å¢å¼ºçš„è„šæœ¬æ­¥éª¤
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SmartScriptStep {
    pub id: String,
    pub step_type: SmartActionType,
    pub name: String,
    pub description: String,
    pub parameters: serde_json::Value,
    pub enabled: bool,
    pub order: i32,
    
    // æ™ºèƒ½åŠŸèƒ½
    pub find_condition: Option<ElementFindCondition>,
    pub verification: Option<VerificationCondition>,
    pub retry_config: Option<RetryConfig>,
    pub fallback_actions: Vec<SmartScriptStep>,
    pub pre_conditions: Vec<PageState>,
    pub post_conditions: Vec<PageState>,
}

/// é‡è¯•é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RetryConfig {
    pub max_retries: u32,
    pub retry_interval_ms: u64,
    pub retry_on_failure: bool,
    pub retry_on_verification_fail: bool,
    pub exponential_backoff: bool,
}

impl Default for RetryConfig {
    fn default() -> Self {
        Self {
            max_retries: 3,
            retry_interval_ms: 1000,
            retry_on_failure: true,
            retry_on_verification_fail: true,
            exponential_backoff: false,
        }
    }
}

// ==================== æ‰§è¡Œç»“æœç³»ç»Ÿ ====================

/// æ™ºèƒ½æ‰§è¡Œç»“æœ
#[derive(Debug, Serialize, Deserialize)]
pub struct SmartExecutionResult {
    pub success: bool,
    pub total_steps: u32,
    pub executed_steps: u32,
    pub failed_steps: u32,
    pub skipped_steps: u32,
    pub duration_ms: u64,
    pub logs: Vec<SmartExecutionLog>,
    pub final_page_state: Option<PageState>,
    pub extracted_data: HashMap<String, serde_json::Value>,
    pub message: String,
}

/// æ™ºèƒ½æ‰§è¡Œæ—¥å¿—
#[derive(Debug, Serialize, Deserialize)]
pub struct SmartExecutionLog {
    pub step_id: String,
    pub step_name: String,
    pub status: ExecutionStatus,
    pub message: String,
    pub timestamp: String,
    pub duration_ms: u64,
    pub retry_count: u32,
    pub page_state_before: Option<PageState>,
    pub page_state_after: Option<PageState>,
    pub found_elements: Vec<SmartUIElement>,
    pub verification_result: Option<VerificationResult>,
    pub extracted_data: Option<serde_json::Value>,
}

/// æ‰§è¡ŒçŠ¶æ€
#[derive(Debug, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ExecutionStatus {
    Pending,
    Running,
    Success,
    Failed,
    Skipped,
    Retrying,
    VerificationFailed,
}

/// éªŒè¯ç»“æœ
#[derive(Debug, Serialize, Deserialize)]
pub struct VerificationResult {
    pub success: bool,
    pub expected: String,
    pub actual: String,
    pub message: String,
}

// ==================== æ™ºèƒ½è„šæœ¬æ‰§è¡Œå™¨ ====================

/// æ™ºèƒ½è„šæœ¬æ‰§è¡Œå™¨ä¸»ç±»
pub struct SmartScriptExecutor {
    pub device_id: String,
    pub adb_path: String,
    pub config: ExecutorConfig,
}

/// æ‰§è¡Œå™¨é…ç½®
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutorConfig {
    pub default_timeout_ms: u64,
    pub default_retry_count: u32,
    pub page_recognition_enabled: bool,
    pub auto_verification_enabled: bool,
    pub smart_recovery_enabled: bool,
    pub detailed_logging: bool,
}

impl Default for ExecutorConfig {
    fn default() -> Self {
        Self {
            default_timeout_ms: 10000,
            default_retry_count: 3,
            page_recognition_enabled: true,
            auto_verification_enabled: true,
            smart_recovery_enabled: true,
            detailed_logging: true,
        }
    }
}

impl SmartScriptExecutor {
    /// åˆ›å»ºæ™ºèƒ½è„šæœ¬æ‰§è¡Œå™¨
    pub fn new(device_id: String) -> Self {
        let adb_path = crate::utils::adb_utils::get_adb_path();
        
        Self {
            device_id,
            adb_path,
            config: ExecutorConfig::default(),
        }
    }

    /// åˆ›å»ºå¸¦è‡ªå®šä¹‰é…ç½®çš„æ‰§è¡Œå™¨
    pub fn new_with_config(device_id: String, config: ExecutorConfig) -> Self {
        let adb_path = crate::utils::adb_utils::get_adb_path();
        
        Self {
            device_id,
            adb_path,
            config,
        }
    }

    /// è¯†åˆ«å½“å‰é¡µé¢çŠ¶æ€
    pub async fn recognize_current_page(&self) -> Result<PageRecognitionResult> {
        info!("ğŸ” å¼€å§‹é¡µé¢è¯†åˆ«...");
        
        // è·å–UIå…ƒç´ 
        let ui_elements = self.get_ui_elements().await?;
        
        // ç®€åŒ–çš„é¡µé¢è¯†åˆ«é€»è¾‘
        let current_state = if ui_elements.iter().any(|e| e.text.contains("é¦–é¡µ") || e.text.contains("ä¸»é¡µ")) {
            PageState::Home
        } else if ui_elements.iter().any(|e| e.text.contains("è®¾ç½®")) {
            PageState::Settings
        } else if ui_elements.iter().any(|e| e.text.contains("åŠ è½½") || e.text.contains("Loading")) {
            PageState::Loading
        } else {
            PageState::Unknown
        };
        
        let confidence = if current_state == PageState::Unknown { 0.3 } else { 0.8 };
        
        Ok(PageRecognitionResult {
            current_state,
            confidence,
            key_elements: vec!["åŸºæœ¬è¯†åˆ«".to_string()],
            ui_elements,
            message: format!("é¡µé¢è¯†åˆ«å®Œæˆ: {:?}", current_state),
            timestamp: chrono::Utc::now().to_rfc3339(),
        })
    }

    /// è·å–UIå…ƒç´ åˆ—è¡¨
    pub async fn get_ui_elements(&self) -> Result<Vec<SmartUIElement>> {
        info!("ğŸ“‹ è·å–UIå…ƒç´ åˆ—è¡¨...");
        
        // æ‰§è¡Œdumpå‘½ä»¤è·å–UIç»“æ„
        let output = self.execute_adb_command(&[
            "-s", &self.device_id,
            "shell", "uiautomator", "dump", "/sdcard/ui_dump.xml"
        ]).await?;
        
        if !output.status.success() {
            return Err(anyhow::anyhow!("UI dump failed: {}", String::from_utf8_lossy(&output.stderr)));
        }
        
        // è·å–XMLå†…å®¹
        let xml_output = self.execute_adb_command(&[
            "-s", &self.device_id,
            "shell", "cat", "/sdcard/ui_dump.xml"
        ]).await?;
        
        if !xml_output.status.success() {
            return Err(anyhow::anyhow!("è¯»å–UI XMLå¤±è´¥"));
        }
        
        let xml_content = String::from_utf8_lossy(&xml_output.stdout);
        
        // ç®€åŒ–çš„XMLè§£æ - æå–åŸºæœ¬å…ƒç´ ä¿¡æ¯
        let mut elements = Vec::new();
        
        // è¿™é‡Œåº”è¯¥æœ‰å®Œæ•´çš„XMLè§£æé€»è¾‘ï¼Œç°åœ¨ä½¿ç”¨ç®€åŒ–ç‰ˆæœ¬
        if xml_content.contains("node") {
            // æ¨¡æ‹Ÿä¸€äº›UIå…ƒç´ 
            elements.push(SmartUIElement {
                element_type: UIElementType::TextView,
                text: "ç¤ºä¾‹æ–‡æœ¬".to_string(),
                bounds: (100, 200, 300, 250),
                center: (200, 225),
                clickable: false,
                visible: true,
                resource_id: None,
                class_name: Some("android.widget.TextView".to_string()),
                content_desc: None,
                package: Some("com.xingin.xhs".to_string()),
            });
            
            elements.push(SmartUIElement {
                element_type: UIElementType::Button,
                text: "ç‚¹å‡»æŒ‰é’®".to_string(),
                bounds: (50, 400, 200, 450),
                center: (125, 425),
                clickable: true,
                visible: true,
                resource_id: Some("com.xingin.xhs:id/button".to_string()),
                class_name: Some("android.widget.Button".to_string()),
                content_desc: Some("å¯ç‚¹å‡»æŒ‰é’®".to_string()),
                package: Some("com.xingin.xhs".to_string()),
            });
        }
        
        info!("âœ… è·å–åˆ° {} ä¸ªUIå…ƒç´ ", elements.len());
        Ok(elements)
    }
        
        Self {
            device_id,
            adb_path,
            config,
        }
    }

    /// æ‰§è¡Œæ™ºèƒ½è„šæœ¬
    pub async fn execute_smart_script(&self, steps: Vec<SmartScriptStep>) -> Result<SmartExecutionResult> {
        let start_time = std::time::Instant::now();
        let mut logs = Vec::new();
        let mut executed_steps = 0;
        let mut failed_steps = 0;
        let skipped_steps = 0;
        let extracted_data = HashMap::new();
        
        info!("ğŸš€ å¼€å§‹æ‰§è¡Œæ™ºèƒ½è„šæœ¬ï¼Œæ€»å…± {} ä¸ªæ­¥éª¤", steps.len());

        // è¿‡æ»¤å¹¶æ’åºå¯ç”¨çš„æ­¥éª¤
        let mut enabled_steps: Vec<_> = steps.into_iter()
            .filter(|step| step.enabled)
            .collect();
        enabled_steps.sort_by_key(|step| step.order);

        // ç®€åŒ–æ‰§è¡Œé€»è¾‘ - æ‰§è¡Œæ¯ä¸ªæ­¥éª¤
        for (index, step) in enabled_steps.iter().enumerate() {
            let step_start = std::time::Instant::now();
            info!("ğŸ“‹ æ‰§è¡Œæ­¥éª¤ {}/{}: {} ({})", index + 1, enabled_steps.len(), step.name, step.step_type.to_string());

            // ç®€å•æ‰§è¡Œæ­¥éª¤
            match self.execute_basic_step(step).await {
                Ok(_) => {
                    executed_steps += 1;
                    
                    let log = SmartExecutionLog {
                        step_id: step.id.clone(),
                        step_name: step.name.clone(),
                        status: ExecutionStatus::Success,
                        message: "æ‰§è¡ŒæˆåŠŸ".to_string(),
                        timestamp: chrono::Utc::now().to_rfc3339(),
                        duration_ms: step_start.elapsed().as_millis() as u64,
                        retry_count: 0,
                        page_state_before: None,
                        page_state_after: None,
                        found_elements: vec![],
                        verification_result: None,
                        extracted_data: None,
                    };
                    logs.push(log);
                }
                Err(e) => {
                    failed_steps += 1;
                    error!("âŒ æ­¥éª¤æ‰§è¡Œå¤±è´¥: {}", e);
                    
                    let log = SmartExecutionLog {
                        step_id: step.id.clone(),
                        step_name: step.name.clone(),
                        status: ExecutionStatus::Failed,
                        message: format!("æ‰§è¡Œå¤±è´¥: {}", e),
                        timestamp: chrono::Utc::now().to_rfc3339(),
                        duration_ms: step_start.elapsed().as_millis() as u64,
                        retry_count: 0,
                        page_state_before: None,
                        page_state_after: None,
                        found_elements: vec![],
                        verification_result: None,
                        extracted_data: None,
                    };
                    logs.push(log);
                }
            }
        }

        let total_duration = start_time.elapsed().as_millis() as u64;
        let success = failed_steps == 0 && executed_steps > 0;

        let result = SmartExecutionResult {
            success,
            total_steps: enabled_steps.len() as u32,
            executed_steps,
            failed_steps,
            skipped_steps,
            duration_ms: total_duration,
            logs,
            final_page_state: None,
            extracted_data,
            message: if success {
                format!("æ™ºèƒ½è„šæœ¬æ‰§è¡ŒæˆåŠŸï¼å…±æ‰§è¡Œ {} ä¸ªæ­¥éª¤ï¼Œè€—æ—¶ {}ms", executed_steps, total_duration)
            } else {
                format!("æ™ºèƒ½è„šæœ¬æ‰§è¡Œå®Œæˆï¼Œ{} ä¸ªæˆåŠŸï¼Œ{} ä¸ªå¤±è´¥ï¼Œ{} ä¸ªè·³è¿‡", executed_steps, failed_steps, skipped_steps)
            },
        };

        info!("âœ… æ™ºèƒ½è„šæœ¬æ‰§è¡Œå®Œæˆ: {}", result.message);
        Ok(result)
    }

    /// æ‰§è¡ŒåŸºç¡€æ­¥éª¤ (ç®€åŒ–ç‰ˆæœ¬)
    async fn execute_basic_step(&self, step: &SmartScriptStep) -> Result<()> {
        match step.step_type {
            SmartActionType::Tap => {
                let params = &step.parameters;
                let x = params["x"].as_i64().context("ç¼ºå°‘xåæ ‡")? as i32;
                let y = params["y"].as_i64().context("ç¼ºå°‘yåæ ‡")? as i32;
                
                info!("ï¿½ ç‚¹å‡»: ({}, {})", x, y);
                self.adb_tap(x, y).await?;
                
                let wait_after = params.get("wait_after").and_then(|v| v.as_u64()).unwrap_or(1000);
                tokio::time::sleep(tokio::time::Duration::from_millis(wait_after)).await;
            }
            SmartActionType::Wait => {
                let params = &step.parameters;
                let duration = params["duration"].as_u64().context("ç¼ºå°‘ç­‰å¾…æ—¶é•¿")?;
                
                info!("â±ï¸ ç­‰å¾…: {}ms", duration);
                tokio::time::sleep(tokio::time::Duration::from_millis(duration)).await;
            }
            _ => {
                return Err(anyhow::anyhow!("æš‚ä¸æ”¯æŒçš„æ“ä½œç±»å‹: {:?}", step.step_type));
            }
        }
        
        Ok(())
    }

    /// ADBç‚¹å‡»
    async fn adb_tap(&self, x: i32, y: i32) -> Result<()> {
        let output = self.execute_adb_command(&[
            "-s", &self.device_id,
            "shell", "input", "tap",
            &x.to_string(), &y.to_string()
        ]).await?;

        if !output.status.success() {
            let error_msg = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow::anyhow!("ç‚¹å‡»å‘½ä»¤æ‰§è¡Œå¤±è´¥: {}", error_msg));
        }

        Ok(())
    }

    /// æ‰§è¡ŒADBå‘½ä»¤
    async fn execute_adb_command(&self, args: &[&str]) -> Result<std::process::Output> {
        let mut cmd = std::process::Command::new(&self.adb_path);
        cmd.args(args);
        
        #[cfg(windows)]
        {
            cmd.creation_flags(0x08000000); // CREATE_NO_WINDOW
        }
        
        let output = cmd.output()
            .context(format!("æ‰§è¡ŒADBå‘½ä»¤å¤±è´¥ - ADBè·¯å¾„: {}, å‚æ•°: {:?}", self.adb_path, args))?;
        
        Ok(output)
    }

    // è¿™é‡Œä¼šåœ¨åç»­ç‰ˆæœ¬ä¸­æ·»åŠ æ›´å¤šæ™ºèƒ½åŠŸèƒ½...

    /// è¯†åˆ«å½“å‰é¡µé¢çŠ¶æ€
    pub async fn recognize_current_page(&self) -> Result<PageRecognitionResult> {
        info!("ğŸ” å¼€å§‹é¡µé¢è¯†åˆ«...");
        
        // è·å–UIå…ƒç´ 
        let ui_elements = self.get_ui_elements().await?;
        
        // ç®€åŒ–çš„é¡µé¢è¯†åˆ«é€»è¾‘
        let current_state = if ui_elements.iter().any(|e| e.text.contains("é¦–é¡µ") || e.text.contains("ä¸»é¡µ")) {
            PageState::Home
        } else if ui_elements.iter().any(|e| e.text.contains("è®¾ç½®")) {
            PageState::Settings
        } else if ui_elements.iter().any(|e| e.text.contains("åŠ è½½") || e.text.contains("Loading")) {
            PageState::Loading
        } else {
            PageState::Unknown
        };
        
        let confidence = if current_state == PageState::Unknown { 0.3 } else { 0.8 };
        
        Ok(PageRecognitionResult {
            current_state,
            confidence,
            key_elements: vec!["åŸºæœ¬è¯†åˆ«".to_string()],
            ui_elements,
            message: format!("é¡µé¢è¯†åˆ«å®Œæˆ: {:?}", current_state),
            timestamp: chrono::Utc::now().to_rfc3339(),
        })
    }

    /// è·å–UIå…ƒç´ åˆ—è¡¨
    pub async fn get_ui_elements(&self) -> Result<Vec<SmartUIElement>> {
        info!("ğŸ“‹ è·å–UIå…ƒç´ åˆ—è¡¨...");
        
        // æ‰§è¡Œdumpå‘½ä»¤è·å–UIç»“æ„
        let output = self.execute_adb_command(&[
            "-s", &self.device_id,
            "shell", "uiautomator", "dump", "/sdcard/ui_dump.xml"
        ]).await?;
        
        if !output.status.success() {
            return Err(anyhow::anyhow!("UI dump failed: {}", String::from_utf8_lossy(&output.stderr)));
        }
        
        // è·å–XMLå†…å®¹
        let xml_output = self.execute_adb_command(&[
            "-s", &self.device_id,
            "shell", "cat", "/sdcard/ui_dump.xml"
        ]).await?;
        
        if !xml_output.status.success() {
            return Err(anyhow::anyhow!("è¯»å–UI XMLå¤±è´¥"));
        }
        
        let xml_content = String::from_utf8_lossy(&xml_output.stdout);
        
        // ç®€åŒ–çš„XMLè§£æ - æå–åŸºæœ¬å…ƒç´ ä¿¡æ¯
        let mut elements = Vec::new();
        
        // è¿™é‡Œåº”è¯¥æœ‰å®Œæ•´çš„XMLè§£æé€»è¾‘ï¼Œç°åœ¨ä½¿ç”¨ç®€åŒ–ç‰ˆæœ¬
        if xml_content.contains("node") {
            // æ¨¡æ‹Ÿä¸€äº›UIå…ƒç´ 
            elements.push(SmartUIElement {
                element_type: UIElementType::TextView,
                text: "ç¤ºä¾‹æ–‡æœ¬".to_string(),
                bounds: (100, 200, 300, 250),
                center: (200, 225),
                clickable: false,
                visible: true,
                resource_id: None,
                class_name: Some("android.widget.TextView".to_string()),
                content_desc: None,
                package: Some("com.xingin.xhs".to_string()),
            });
            
            elements.push(SmartUIElement {
                element_type: UIElementType::Button,
                text: "ç‚¹å‡»æŒ‰é’®".to_string(),
                bounds: (50, 400, 200, 450),
                center: (125, 425),
                clickable: true,
                visible: true,
                resource_id: Some("com.xingin.xhs:id/button".to_string()),
                class_name: Some("android.widget.Button".to_string()),
                content_desc: Some("å¯ç‚¹å‡»æŒ‰é’®".to_string()),
                package: Some("com.xingin.xhs".to_string()),
            });
        }
        
        info!("âœ… è·å–åˆ° {} ä¸ªUIå…ƒç´ ", elements.len());
        Ok(elements)
    }

    /// æ‰§è¡Œå•ä¸ªæ­¥éª¤è¿›è¡Œæµ‹è¯•
    pub async fn execute_single_step(&self, step: SmartScriptStep) -> Result<SingleStepTestResult> {
        let start_time = std::time::Instant::now();
        let timestamp = chrono::Utc::now().timestamp_millis();
        let mut logs = Vec::new();
        let mut extracted_data = HashMap::new();
        let mut ui_elements = Vec::new();
        let mut page_state = None;

        info!("ğŸ§ª å¼€å§‹å•æ­¥æµ‹è¯•: {} - {}", step.name, step.description);
        logs.push(format!("å¼€å§‹æ‰§è¡Œæ­¥éª¤: {}", step.name));

        // æ£€æŸ¥å‰ç½®æ¡ä»¶
        if !step.pre_conditions.is_empty() {
            logs.push("æ£€æŸ¥å‰ç½®æ¡ä»¶...".to_string());
            match self.recognize_current_page().await {
                Ok(recognition) => {
                    page_state = Some(format!("{:?}", recognition.current_state));
                    if !step.pre_conditions.contains(&format!("{:?}", recognition.current_state)) {
                        let error = format!(
                            "å‰ç½®æ¡ä»¶ä¸æ»¡è¶³ã€‚å½“å‰é¡µé¢: {:?}, è¦æ±‚é¡µé¢: {:?}",
                            recognition.current_state, step.pre_conditions
                        );
                        logs.push(error.clone());
                        
                        return Ok(SingleStepTestResult {
                            success: false,
                            step_id: step.id,
                            step_name: step.name,
                            message: "å‰ç½®æ¡ä»¶æ£€æŸ¥å¤±è´¥".to_string(),
                            duration_ms: start_time.elapsed().as_millis() as u64,
                            timestamp,
                            page_state,
                            ui_elements,
                            logs,
                            error_details: Some(error),
                            extracted_data,
                        });
                    }
                }
                Err(e) => {
                    logs.push(format!("é¡µé¢è¯†åˆ«å¤±è´¥: {}", e));
                }
            }
        }

        // ç®€åŒ–çš„æµ‹è¯•æ‰§è¡Œé€»è¾‘
        let execution_result = {
            logs.push(format!("æ‰§è¡Œæ­¥éª¤ç±»å‹: {:?}", step.step_type));
            tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
            logs.push("æ­¥éª¤æ‰§è¡Œå®Œæˆ".to_string());
            Ok("æµ‹è¯•æ‰§è¡ŒæˆåŠŸ".to_string())
        };

        let duration = start_time.elapsed().as_millis() as u64;
        
        match execution_result {
            Ok(message) => {
                logs.push(format!("æ­¥éª¤æ‰§è¡ŒæˆåŠŸ: {}", message));
                info!("âœ… å•æ­¥æµ‹è¯•æˆåŠŸ: {} ({}ms)", step.name, duration);
                
                Ok(SingleStepTestResult {
                    success: true,
                    step_id: step.id,
                    step_name: step.name,
                    message,
                    duration_ms: duration,
                    timestamp,
                    page_state,
                    ui_elements,
                    logs,
                    error_details: None,
                    extracted_data,
                })
            }
            Err(e) => {
                let error_msg = e.to_string();
                logs.push(format!("æ­¥éª¤æ‰§è¡Œå¤±è´¥: {}", error_msg));
                error!("âŒ å•æ­¥æµ‹è¯•å¤±è´¥: {} - {}", step.name, error_msg);
                
                Ok(SingleStepTestResult {
                    success: false,
                    step_id: step.id,
                    step_name: step.name,
                    message: "æ­¥éª¤æ‰§è¡Œå¤±è´¥".to_string(),
                    duration_ms: duration,
                    timestamp,
                    page_state,
                    ui_elements,
                    logs,
                    error_details: Some(error_msg),
                    extracted_data,
                })
            }
        }
    }
}

// ==================== è¾…åŠ©å‡½æ•° ====================

impl SmartActionType {
    pub fn to_string(&self) -> String {
        match self {
            Self::Tap => "åŸºç¡€ç‚¹å‡»".to_string(),
            Self::SmartTap => "æ™ºèƒ½ç‚¹å‡»".to_string(),
            Self::SmartFindElement => "æ™ºèƒ½æŸ¥æ‰¾å…ƒç´ ".to_string(),
            Self::RecognizePage => "é¡µé¢è¯†åˆ«".to_string(),
            Self::VerifyAction => "æ“ä½œéªŒè¯".to_string(),
            Self::SmartLoop => "æ™ºèƒ½å¾ªç¯".to_string(),
            Self::ConditionalAction => "æ¡ä»¶æ“ä½œ".to_string(),
            Self::WaitForPageState => "ç­‰å¾…é¡µé¢çŠ¶æ€".to_string(),
            Self::ExtractElement => "æå–å…ƒç´ ä¿¡æ¯".to_string(),
            Self::SmartNavigation => "æ™ºèƒ½å¯¼èˆª".to_string(),
            Self::CompleteWorkflow => "å®Œæ•´å·¥ä½œæµç¨‹".to_string(),
            _ => format!("{:?}", self),
        }
    }
}

// Tauriå‘½ä»¤å¯¼å‡º
#[command]
pub async fn execute_smart_automation_script(
    device_id: String,
    steps: Vec<SmartScriptStep>,
    config: Option<ExecutorConfig>,
) -> Result<SmartExecutionResult, String> {
    info!("ğŸ¯ æ”¶åˆ°æ™ºèƒ½è„šæœ¬æ‰§è¡Œè¯·æ±‚ï¼Œè®¾å¤‡: {}, æ­¥éª¤æ•°: {}", device_id, steps.len());

    let executor = if let Some(cfg) = config {
        SmartScriptExecutor::new_with_config(device_id, cfg)
    } else {
        SmartScriptExecutor::new(device_id)
    };
    
    match executor.execute_smart_script(steps).await {
        Ok(result) => {
            info!("âœ… æ™ºèƒ½è„šæœ¬æ‰§è¡Œå®Œæˆ: {}", result.message);
            Ok(result)
        }
        Err(e) => {
            error!("âŒ æ™ºèƒ½è„šæœ¬æ‰§è¡Œå¤±è´¥: {}", e);
            Err(format!("æ™ºèƒ½è„šæœ¬æ‰§è¡Œå¤±è´¥: {}", e))
        }
    }
}

/// å•æ­¥æµ‹è¯•æ‰§è¡Œç»“æœ
#[derive(Debug, Serialize, Deserialize)]
pub struct SingleStepTestResult {
    pub success: bool,
    pub step_id: String,
    pub step_name: String,
    pub message: String,
    pub duration_ms: u64,
    pub timestamp: i64,
    pub page_state: Option<String>,
    pub ui_elements: Vec<SmartUIElement>,
    pub logs: Vec<String>,
    pub error_details: Option<String>,
    pub extracted_data: HashMap<String, serde_json::Value>,
}

#[command]
pub async fn execute_single_step_test(
    device_id: String,
    step: SmartScriptStep,
) -> Result<SingleStepTestResult, String> {
    info!("ğŸ§ª æ”¶åˆ°å•æ­¥æµ‹è¯•è¯·æ±‚ï¼Œè®¾å¤‡: {}, æ­¥éª¤: {}", device_id, step.name);

    let executor = SmartScriptExecutor::new(device_id);
    
    match executor.execute_single_step(step).await {
        Ok(result) => {
            if result.success {
                info!("âœ… å•æ­¥æµ‹è¯•æˆåŠŸ: {}", result.message);
            } else {
                info!("âŒ å•æ­¥æµ‹è¯•å¤±è´¥: {}", result.message);
            }
            Ok(result)
        }
        Err(e) => {
            error!("âŒ å•æ­¥æµ‹è¯•æ‰§è¡Œå¼‚å¸¸: {}", e);
            Err(format!("å•æ­¥æµ‹è¯•æ‰§è¡Œå¼‚å¸¸: {}", e))
        }
    }
}
        logs.push("æ‰§è¡Œé¡µé¢çŠ¶æ€ç­‰å¾…æµ‹è¯•...".to_string());
        
        // ä»å‚æ•°ä¸­è·å–ç›®æ ‡çŠ¶æ€å’Œè¶…æ—¶æ—¶é—´
        let params: HashMap<String, serde_json::Value> = serde_json::from_value(step.parameters.clone())
            .unwrap_or_default();
            
        let target_state = params.get("target_state")
            .and_then(|v| v.as_str())
            .unwrap_or("unknown");
            
        let timeout_ms = params.get("timeout_ms")
            .and_then(|v| v.as_u64())
            .unwrap_or(5000);
            
        logs.push(format!("ç­‰å¾…é¡µé¢çŠ¶æ€: {}, è¶…æ—¶: {}ms", target_state, timeout_ms));
        
        let start = std::time::Instant::now();
        let timeout = std::time::Duration::from_millis(timeout_ms);
        
        while start.elapsed() < timeout {
            match self.recognize_current_page().await {
                Ok(recognition) => {
                    let current_state_str = format!("{:?}", recognition.current_state).to_lowercase();
                    *page_state = Some(current_state_str.clone());
                    
                    if current_state_str.contains(target_state) {
                        logs.push(format!("æˆåŠŸç­‰å¾…åˆ°ç›®æ ‡é¡µé¢çŠ¶æ€: {}", current_state_str));
                        return Ok(format!("é¡µé¢çŠ¶æ€å·²å˜æ›´ä¸º: {}", current_state_str));
                    }
                    
                    logs.push(format!("å½“å‰é¡µé¢: {}, ç»§ç»­ç­‰å¾…...", current_state_str));
                }
                Err(e) => {
                    logs.push(format!("é¡µé¢è¯†åˆ«é”™è¯¯: {}", e));
                }
            }
            
            tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
        }
        
        Err(anyhow::anyhow!("ç­‰å¾…é¡µé¢çŠ¶æ€è¶…æ—¶"))
    }

    async fn execute_basic_tap_test(
        &self,
        step: &SmartScriptStep,
        logs: &mut Vec<String>,
    ) -> Result<String> {
        logs.push("æ‰§è¡ŒåŸºç¡€ç‚¹å‡»æµ‹è¯•...".to_string());
        
        let params: HashMap<String, serde_json::Value> = serde_json::from_value(step.parameters.clone())
            .map_err(|e| anyhow::anyhow!("å‚æ•°è§£æå¤±è´¥: {}", e))?;
            
        let x = params.get("x")
            .and_then(|v| v.as_i64())
            .ok_or_else(|| anyhow::anyhow!("ç¼ºå°‘xåæ ‡"))? as i32;
            
        let y = params.get("y")
            .and_then(|v| v.as_i64())
            .ok_or_else(|| anyhow::anyhow!("ç¼ºå°‘yåæ ‡"))? as i32;
            
        self.execute_adb_command(&[
            "-s", &self.device_id,
            "shell", "input", "tap",
            &x.to_string(), &y.to_string()
        ]).await?;
        
        logs.push(format!("ç‚¹å‡»åæ ‡: ({}, {})", x, y));
        
        Ok(format!("æˆåŠŸç‚¹å‡»åæ ‡: ({}, {})", x, y))
    }

    async fn execute_input_test(
        &self,
        step: &SmartScriptStep,
        logs: &mut Vec<String>,
    ) -> Result<String> {
        logs.push("æ‰§è¡Œè¾“å…¥æµ‹è¯•...".to_string());
        
        let params: HashMap<String, serde_json::Value> = serde_json::from_value(step.parameters.clone())
            .map_err(|e| anyhow::anyhow!("å‚æ•°è§£æå¤±è´¥: {}", e))?;
            
        let text = params.get("text")
            .and_then(|v| v.as_str())
            .ok_or_else(|| anyhow::anyhow!("ç¼ºå°‘è¾“å…¥æ–‡æœ¬"))?;
            
        self.execute_adb_command(&[
            "-s", &self.device_id,
            "shell", "input", "text",
            text
        ]).await?;
        
        logs.push(format!("è¾“å…¥æ–‡æœ¬: {}", text));
        
        Ok(format!("æˆåŠŸè¾“å…¥æ–‡æœ¬: {}", text))
    }

    async fn execute_wait_test(
        &self,
        step: &SmartScriptStep,
        logs: &mut Vec<String>,
    ) -> Result<String> {
        logs.push("æ‰§è¡Œç­‰å¾…æµ‹è¯•...".to_string());
        
        let params: HashMap<String, serde_json::Value> = serde_json::from_value(step.parameters.clone())
            .map_err(|e| anyhow::anyhow!("å‚æ•°è§£æå¤±è´¥: {}", e))?;
            
        let duration_ms = params.get("duration_ms")
            .and_then(|v| v.as_u64())
            .unwrap_or(1000);
            
        logs.push(format!("ç­‰å¾… {}ms...", duration_ms));
        
        tokio::time::sleep(tokio::time::Duration::from_millis(duration_ms)).await;
        
        Ok(format!("ç­‰å¾…å®Œæˆ: {}ms", duration_ms))
    }

    // è¾…åŠ©æ–¹æ³•ï¼šæ£€æŸ¥å…ƒç´ æ˜¯å¦åŒ¹é…æ¡ä»¶
    fn matches_condition(&self, element: &SmartUIElement, condition: &ElementFindCondition) -> bool {
        // æ–‡æœ¬åŒ…å«æ£€æŸ¥
        if let Some(text_contains) = &condition.text_contains {
            if !element.text.to_lowercase().contains(&text_contains.to_lowercase()) {
                return false;
            }
        }
        
        // æ–‡æœ¬ç›¸ç­‰æ£€æŸ¥
        if let Some(text_equals) = &condition.text_equals {
            if element.text != *text_equals {
                return false;
            }
        }
        
        // èµ„æºIDæ£€æŸ¥
        if let Some(resource_id) = &condition.resource_id {
            if element.resource_id.as_ref() != Some(resource_id) {
                return false;
            }
        }
        
        // å¯ç‚¹å‡»æ€§æ£€æŸ¥
        if let Some(clickable) = condition.clickable {
            if element.clickable != clickable {
                return false;
            }
        }
        
        // å¯è§æ€§æ£€æŸ¥
        if let Some(visible) = condition.visible {
            if element.visible != visible {
                return false;
            }
        }
        
        // å…ƒç´ ç±»å‹æ£€æŸ¥
        if let Some(element_type) = &condition.element_type {
            if element.element_type != *element_type {
                return false;
            }
        }
        
        true
    }
}

#[command]
pub async fn execute_single_step_test(
    device_id: String,
    step: SmartScriptStep,
) -> Result<SingleStepTestResult, String> {
    info!("ğŸ§ª æ”¶åˆ°å•æ­¥æµ‹è¯•è¯·æ±‚ï¼Œè®¾å¤‡: {}, æ­¥éª¤: {}", device_id, step.name);

    let executor = SmartScriptExecutor::new(device_id);
    
    match executor.execute_single_step(step).await {
        Ok(result) => {
            if result.success {
                info!("âœ… å•æ­¥æµ‹è¯•æˆåŠŸ: {}", result.message);
            } else {
                info!("âŒ å•æ­¥æµ‹è¯•å¤±è´¥: {}", result.message);
            }
            Ok(result)
        }
        Err(e) => {
            error!("âŒ å•æ­¥æµ‹è¯•æ‰§è¡Œå¼‚å¸¸: {}", e);
            Err(format!("å•æ­¥æµ‹è¯•æ‰§è¡Œå¼‚å¸¸: {}", e))
        }
    }
}