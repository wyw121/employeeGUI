use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::process::Command;
use tokio::time::{sleep, Duration};
use tracing::{error, info, warn};

// åº”ç”¨çŠ¶æ€æ£€æŸ¥ç»“æœ
#[derive(Debug, Serialize, Deserialize)]
pub struct AppStatusResult {
    pub app_installed: bool,
    pub app_running: bool,
    pub message: String,
    pub app_version: Option<String>,
    pub package_name: Option<String>,
}

// å¯¼èˆªæ“ä½œç»“æœ
#[derive(Debug, Serialize, Deserialize)]
pub struct NavigationResult {
    pub success: bool,
    pub message: String,
}

// å…³æ³¨æ“ä½œé…ç½®
#[derive(Debug, Serialize, Deserialize, Clone)]
pub struct XiaohongshuFollowOptions {
    pub max_pages: Option<usize>,
    pub follow_interval: Option<u64>,
    pub skip_existing: Option<bool>,
    pub return_to_home: Option<bool>,
}

impl Default for XiaohongshuFollowOptions {
    fn default() -> Self {
        Self {
            max_pages: Some(5),
            follow_interval: Some(2000),
            skip_existing: Some(true),
            return_to_home: Some(true),
        }
    }
}

// å…³æ³¨æ“ä½œç»“æœ
#[derive(Debug, Serialize, Deserialize)]
pub struct XiaohongshuFollowResult {
    pub success: bool,
    pub total_followed: usize,
    pub pages_processed: usize,
    pub duration: u64,
    pub details: Vec<FollowDetail>,
    pub message: String,
}

// å•ä¸ªå…³æ³¨æ“ä½œçš„è¯¦ç»†ä¿¡æ¯
#[derive(Debug, Serialize, Deserialize)]
pub struct FollowDetail {
    pub user_position: (i32, i32),
    pub follow_success: bool,
    pub button_text_before: Option<String>,
    pub button_text_after: Option<String>,
    pub error: Option<String>,
}

// é¡µé¢çŠ¶æ€æšä¸¾
#[derive(Debug, Clone, PartialEq)]
pub enum PageState {
    Unknown,         // æœªçŸ¥é¡µé¢
    MainPage,        // å°çº¢ä¹¦ä¸»é¡µ
    SidebarOpen,     // ä¾§è¾¹æ å·²æ‰“å¼€
    DiscoverFriends, // å‘ç°å¥½å‹é¡µé¢
    ContactsList,    // é€šè®¯å½•åˆ—è¡¨é¡µé¢
    UserProfile,     // ç”¨æˆ·èµ„æ–™é¡µé¢
}

// é¡µé¢è¯†åˆ«ç»“æœ
#[derive(Debug, Clone)]
pub struct PageRecognitionResult {
    pub current_state: PageState,
    pub confidence: f32,
    pub key_elements: Vec<String>,
    pub ui_elements: Vec<UIElement>,
    pub message: String,
}

// UIå…ƒç´ ä¿¡æ¯
#[derive(Debug, Clone)]
pub struct UIElement {
    pub element_type: UIElementType,
    pub text: String,
    pub bounds: (i32, i32, i32, i32), // (left, top, right, bottom)
    pub clickable: bool,
    pub resource_id: Option<String>,
    pub class_name: Option<String>,
}

// UIå…ƒç´ ç±»å‹
#[derive(Debug, Clone, PartialEq)]
pub enum UIElementType {
    Button,
    TextView,
    ImageView,
    EditText,
    RecyclerView,
    LinearLayout,
    RelativeLayout,
    Unknown,
}

// å±å¹•ä¿¡æ¯
#[derive(Debug)]
struct ScreenInfo {
    width: i32,
    height: i32,
}

pub struct XiaohongshuAutomator {
    device_id: String,
    adb_path: String,
}

impl XiaohongshuAutomator {
    pub fn new(device_id: String) -> Self {
        Self {
            device_id,
            adb_path: "D:\\leidian\\LDPlayer9\\adb.exe".to_string(),
        }
    }

    /// æ™ºèƒ½é¡µé¢è¯†åˆ«
    pub async fn recognize_current_page(&self) -> Result<PageRecognitionResult> {
        info!("ğŸ” å¼€å§‹è¯†åˆ«å½“å‰é¡µé¢çŠ¶æ€...");

        let ui_dump = self.get_ui_dump().await?;
        let ui_elements = self.parse_ui_elements(&ui_dump).await?;
        
        // åˆ†æé¡µé¢ç‰¹å¾
        let (page_state, confidence, key_elements) = self.analyze_page_state(&ui_dump, &ui_elements).await?;
        
        let message = format!("è¯†åˆ«åˆ°é¡µé¢: {:?}, ä¿¡å¿ƒåº¦: {:.2}", page_state, confidence);
        info!("ğŸ“‹ {}", message);
        
        Ok(PageRecognitionResult {
            current_state: page_state,
            confidence,
            key_elements,
            ui_elements,
            message,
        })
    }

    /// åˆ†æé¡µé¢çŠ¶æ€
    async fn analyze_page_state(&self, ui_dump: &str, _ui_elements: &[UIElement]) -> Result<(PageState, f32, Vec<String>)> {
        let mut key_elements = Vec::new();
        let mut confidence_scores = Vec::new();

        // æ£€æŸ¥ä¸»é¡µç‰¹å¾
        if ui_dump.contains("é¦–é¡µ") || ui_dump.contains("æ¨è") || ui_dump.contains("å…³æ³¨") && ui_dump.contains("å‘ç°") {
            key_elements.push("ä¸»é¡µå¯¼èˆª".to_string());
            confidence_scores.push((PageState::MainPage, 0.8));
        }

        // æ£€æŸ¥ä¾§è¾¹æ ç‰¹å¾
        if ui_dump.contains("è®¾ç½®") || ui_dump.contains("æˆ‘çš„ä¸»é¡µ") || ui_dump.contains("å‘ç°å¥½å‹") {
            key_elements.push("ä¾§è¾¹æ èœå•".to_string());
            confidence_scores.push((PageState::SidebarOpen, 0.9));
        }

        // æ£€æŸ¥å‘ç°å¥½å‹é¡µé¢ç‰¹å¾
        if ui_dump.contains("å‘ç°å¥½å‹") || (ui_dump.contains("é€šè®¯å½•") && ui_dump.contains("å¥½å‹")) {
            key_elements.push("å‘ç°å¥½å‹é¡µé¢".to_string());
            confidence_scores.push((PageState::DiscoverFriends, 0.85));
        }

        // æ£€æŸ¥é€šè®¯å½•é¡µé¢ç‰¹å¾
        if (ui_dump.contains("é€šè®¯å½•") || ui_dump.contains("è”ç³»äºº")) && 
           (ui_dump.contains("å…³æ³¨") || ui_dump.contains("å·²å…³æ³¨") || ui_dump.contains("follow")) {
            key_elements.push("é€šè®¯å½•å…³æ³¨åˆ—è¡¨".to_string());
            confidence_scores.push((PageState::ContactsList, 0.9));
        }

        // æ£€æŸ¥ç”¨æˆ·èµ„æ–™é¡µé¢ç‰¹å¾
        if ui_dump.contains("ç²‰ä¸") && ui_dump.contains("å…³æ³¨") && ui_dump.contains("è·èµ") {
            key_elements.push("ç”¨æˆ·èµ„æ–™é¡µé¢".to_string());
            confidence_scores.push((PageState::UserProfile, 0.85));
        }

        // ç¡®å®šæœ€ä½³åŒ¹é…
        if let Some((page_state, confidence)) = confidence_scores.into_iter().max_by(|a, b| a.1.partial_cmp(&b.1).unwrap()) {
            Ok((page_state, confidence, key_elements))
        } else {
            Ok((PageState::Unknown, 0.0, key_elements))
        }
    }

    /// è§£æUIå…ƒç´ 
    async fn parse_ui_elements(&self, ui_dump: &str) -> Result<Vec<UIElement>> {
        let mut elements = Vec::new();
        
        // ç®€åŒ–çš„XMLè§£æ - æŸ¥æ‰¾å¯ç‚¹å‡»å…ƒç´ 
        for line in ui_dump.lines() {
            if line.contains("clickable=\"true\"") || line.contains("å…³æ³¨") || line.contains("å‘ç°å¥½å‹") {
                if let Some(element) = self.parse_ui_element_line(line) {
                    elements.push(element);
                }
            }
        }

        info!("ğŸ“± è§£æåˆ° {} ä¸ªå¯æ“ä½œUIå…ƒç´ ", elements.len());
        Ok(elements)
    }

    /// è§£æå•ä¸ªUIå…ƒç´ è¡Œ
    fn parse_ui_element_line(&self, line: &str) -> Option<UIElement> {
        // ç®€åŒ–çš„å±æ€§æå–
        let text = self.extract_attribute(line, "text").unwrap_or_default();
        let resource_id = self.extract_attribute(line, "resource-id");
        let class_name = self.extract_attribute(line, "class");
        let bounds_str = self.extract_attribute(line, "bounds")?;
        
        // è§£æbounds: [left,top][right,bottom]
        let bounds = self.parse_bounds(&bounds_str)?;
        
        let element_type = if line.contains("Button") || text.contains("å…³æ³¨") {
            UIElementType::Button
        } else if line.contains("TextView") {
            UIElementType::TextView
        } else {
            UIElementType::Unknown
        };

        Some(UIElement {
            element_type,
            text,
            bounds,
            clickable: line.contains("clickable=\"true\""),
            resource_id,
            class_name,
        })
    }

    /// æå–XMLå±æ€§å€¼
    fn extract_attribute(&self, line: &str, attr_name: &str) -> Option<String> {
        let pattern = format!("{}=\"", attr_name);
        if let Some(start) = line.find(&pattern) {
            let start = start + pattern.len();
            if let Some(end) = line[start..].find('"') {
                return Some(line[start..start + end].to_string());
            }
        }
        None
    }

    /// è§£æboundsåæ ‡
    fn parse_bounds(&self, bounds_str: &str) -> Option<(i32, i32, i32, i32)> {
        // æ ¼å¼: [left,top][right,bottom]
        let coords: Vec<i32> = bounds_str
            .replace("[", "")
            .replace("]", ",")
            .split(',')
            .filter_map(|s| s.trim().parse().ok())
            .collect();
        
        if coords.len() >= 4 {
            Some((coords[0], coords[1], coords[2], coords[3]))
        } else {
            None
        }
    }

    /// è·å–UI dump
    async fn get_ui_dump(&self) -> Result<String> {
        // æ–¹æ³•1: ç›´æ¥è¾“å‡ºåˆ°stdout
        let output1 = Command::new(&self.adb_path)
            .args(&["-s", &self.device_id, "shell", "uiautomator", "dump", "/dev/stdout"])
            .output()
            .context("è·å–UI dumpå¤±è´¥")?;

        let result1 = String::from_utf8_lossy(&output1.stdout).to_string();
        
        if result1.len() > 100 && result1.contains("<?xml") {
            return Ok(result1);
        }

        // æ–¹æ³•2: å…ˆdumpåˆ°æ–‡ä»¶ï¼Œå†cat
        let _dump_output = Command::new(&self.adb_path)
            .args(&["-s", &self.device_id, "shell", "uiautomator", "dump", "/sdcard/ui_dump.xml"])
            .output()
            .context("dumpåˆ°æ–‡ä»¶å¤±è´¥")?;

        let output2 = Command::new(&self.adb_path)
            .args(&["-s", &self.device_id, "shell", "cat", "/sdcard/ui_dump.xml"])
            .output()
            .context("è¯»å–UI dumpæ–‡ä»¶å¤±è´¥")?;

        let result2 = String::from_utf8_lossy(&output2.stdout).to_string();
        
        if result2.len() > 100 && result2.contains("<?xml") {
            return Ok(result2);
        }

        anyhow::bail!("æ— æ³•è·å–æœ‰æ•ˆçš„UI dump");
    }

    /// æ™ºèƒ½æŸ¥æ‰¾å…³æ³¨æŒ‰é’®
    async fn find_follow_buttons(&self) -> Result<Vec<(i32, i32)>> {
        info!("ğŸ” æ™ºèƒ½åˆ†æé¡µé¢ä¸­çš„å…³æ³¨æŒ‰é’®...");

        let page_recognition = self.recognize_current_page().await?;
        
        if page_recognition.current_state != PageState::ContactsList {
            warn!("âš ï¸ å½“å‰ä¸åœ¨é€šè®¯å½•é¡µé¢ï¼ŒçŠ¶æ€: {:?}", page_recognition.current_state);
            return Ok(vec![]);
        }

        let mut buttons = Vec::new();

        // ä»UIå…ƒç´ ä¸­æŸ¥æ‰¾å…³æ³¨æŒ‰é’®
        for element in &page_recognition.ui_elements {
            if element.element_type == UIElementType::Button && element.clickable {
                let button_text = element.text.to_lowercase();
                
                // æ£€æŸ¥æ˜¯å¦æ˜¯å…³æ³¨ç›¸å…³æŒ‰é’®
                if button_text.contains("å…³æ³¨") || button_text.contains("follow") || 
                   button_text.contains("å·²å…³æ³¨") || button_text.contains("following") {
                    
                    let center_x = (element.bounds.0 + element.bounds.2) / 2;
                    let center_y = (element.bounds.1 + element.bounds.3) / 2;
                    
                    buttons.push((center_x, center_y));
                    info!("âœ… æ‰¾åˆ°å…³æ³¨æŒ‰é’® åæ ‡:({}, {}) æ–‡æœ¬:'{}'", center_x, center_y, element.text);
                }
            }
        }

        // å¦‚æœé€šè¿‡UIå…ƒç´ æ²¡æ‰¾åˆ°ï¼Œå°è¯•é€šè¿‡UI dumpçš„æ–‡æœ¬å®šä½
        if buttons.is_empty() {
            info!("ğŸ”„ UIå…ƒç´ åˆ†ææœªæ‰¾åˆ°æŒ‰é’®ï¼Œå°è¯•æ–‡æœ¬å®šä½...");
            buttons = self.find_buttons_by_text_pattern().await?;
        }

        info!("ğŸ“Š æ€»å…±æ‰¾åˆ° {} ä¸ªå…³æ³¨æŒ‰é’®ä½ç½®", buttons.len());
        Ok(buttons)
    }

    /// é€šè¿‡æ–‡æœ¬æ¨¡å¼æŸ¥æ‰¾æŒ‰é’®
    async fn find_buttons_by_text_pattern(&self) -> Result<Vec<(i32, i32)>> {
        let ui_dump = self.get_ui_dump().await?;
        let screen_info = self.get_screen_info().await?;
        
        let mut buttons = Vec::new();
        
        // åˆ†æUI dumpä¸­çš„å…³æ³¨æ–‡æœ¬ä½ç½®
        for line in ui_dump.lines() {
            if line.contains("å…³æ³¨") || line.contains("follow") {
                if let Some(bounds) = self.extract_bounds_from_line(line) {
                    let center_x = (bounds.0 + bounds.2) / 2;
                    let center_y = (bounds.1 + bounds.3) / 2;
                    
                    // éªŒè¯åæ ‡åˆç†æ€§
                    if center_x > 0 && center_x < screen_info.width &&
                       center_y > 0 && center_y < screen_info.height {
                        buttons.push((center_x, center_y));
                        info!("ğŸ“ æ–‡æœ¬å®šä½æ‰¾åˆ°æŒ‰é’® åæ ‡:({}, {})", center_x, center_y);
                    }
                }
            }
        }
        
        Ok(buttons)
    }

    /// ä»UI dumpè¡Œä¸­æå–bounds
    fn extract_bounds_from_line(&self, line: &str) -> Option<(i32, i32, i32, i32)> {
        if let Some(bounds_str) = self.extract_attribute(line, "bounds") {
            self.parse_bounds(&bounds_str)
        } else {
            None
        }
    }

    /// è·å–å±å¹•ä¿¡æ¯
    async fn get_screen_info(&self) -> Result<ScreenInfo> {
        let output = Command::new(&self.adb_path)
            .args(&["-s", &self.device_id, "shell", "wm", "size"])
            .output()
            .context("è·å–å±å¹•å°ºå¯¸å¤±è´¥")?;

        let output_str = String::from_utf8_lossy(&output.stdout);
        
        // è§£æè¾“å‡ºæ ¼å¼ï¼šPhysical size: 1080x2340
        if let Some(size_line) = output_str.lines().find(|line| line.contains("Physical size") || line.contains("size:")) {
            if let Some(size_part) = size_line.split(':').nth(1) {
                let size_part = size_part.trim();
                if let Some((width_str, height_str)) = size_part.split_once('x') {
                    let width = width_str.parse::<i32>().unwrap_or(1080);
                    let height = height_str.parse::<i32>().unwrap_or(2340);
                    return Ok(ScreenInfo { width, height });
                }
            }
        }

        // é»˜è®¤å±å¹•å°ºå¯¸
        warn!("æ— æ³•è§£æå±å¹•å°ºå¯¸ï¼Œä½¿ç”¨é»˜è®¤å€¼");
        Ok(ScreenInfo { width: 1080, height: 2340 })
    }

    /// æ£€æŸ¥å°çº¢ä¹¦åº”ç”¨çŠ¶æ€
    pub async fn check_app_status(&self) -> Result<AppStatusResult> {
        info!("æ£€æŸ¥å°çº¢ä¹¦åº”ç”¨çŠ¶æ€");

        // æ£€æŸ¥æ˜¯å¦å®‰è£…
        let installed = self.is_app_installed("com.xingin.xhs").await?;

        // æ£€æŸ¥æ˜¯å¦è¿è¡Œ
        let running = if installed {
            self.is_app_running("com.xingin.xhs").await?
        } else {
            false
        };

        // è·å–åº”ç”¨ç‰ˆæœ¬ï¼ˆç®€åŒ–å¤„ç†ï¼‰
        let app_version = if installed {
            Some("æœªçŸ¥ç‰ˆæœ¬".to_string())
        } else {
            None
        };

        let message = match (installed, running) {
            (false, _) => "å°çº¢ä¹¦åº”ç”¨æœªå®‰è£…".to_string(),
            (true, false) => "å°çº¢ä¹¦åº”ç”¨å·²å®‰è£…ä½†æœªè¿è¡Œ".to_string(),
            (true, true) => "å°çº¢ä¹¦åº”ç”¨å·²å®‰è£…ä¸”æ­£åœ¨è¿è¡Œ".to_string(),
        };

        Ok(AppStatusResult {
            app_installed: installed,
            app_running: running,
            message,
            app_version,
            package_name: Some("com.xingin.xhs".to_string()),
        })
    }

    /// æ£€æŸ¥åº”ç”¨æ˜¯å¦å®‰è£…
    async fn is_app_installed(&self, package_name: &str) -> Result<bool> {
        let output = Command::new(&self.adb_path)
            .args(&[
                "-s",
                &self.device_id,
                "shell",
                "pm",
                "list",
                "packages",
                package_name,
            ])
            .output()
            .context("æ£€æŸ¥åº”ç”¨å®‰è£…çŠ¶æ€å¤±è´¥")?;

        Ok(output.status.success() && !output.stdout.is_empty())
    }

    /// æ£€æŸ¥åº”ç”¨æ˜¯å¦è¿è¡Œ
    async fn is_app_running(&self, package_name: &str) -> Result<bool> {
        let output = Command::new(&self.adb_path)
            .args(&[
                "-s",
                &self.device_id,
                "shell",
                "ps",
                "|",
                "grep",
                package_name,
            ])
            .output()
            .context("æ£€æŸ¥åº”ç”¨è¿è¡ŒçŠ¶æ€å¤±è´¥")?;

        Ok(!output.stdout.is_empty())
    }

    /// å¯¼èˆªåˆ°å°çº¢ä¹¦é€šè®¯å½•é¡µé¢
    pub async fn navigate_to_contacts(&self) -> Result<NavigationResult> {
        info!("å¯¼èˆªåˆ°å°çº¢ä¹¦é€šè®¯å½•é¡µé¢");

        let mut attempts = 0;
        let max_attempts = 3;

        while attempts < max_attempts {
            attempts += 1;

            // 1. å¯åŠ¨å°çº¢ä¹¦åº”ç”¨
            if let Err(e) = self.open_xiaohongshu_app().await {
                warn!("å¯åŠ¨å°çº¢ä¹¦å¤±è´¥ (å°è¯• {}): {}", attempts, e);
                continue;
            }

            sleep(Duration::from_secs(3)).await;

            // 2. å°è¯•å¯¼èˆªåˆ°é€šè®¯å½•
            match self.navigate_to_contacts_internal().await {
                Ok(_) => {
                    return Ok(NavigationResult {
                        success: true,
                        message: "æˆåŠŸå¯¼èˆªåˆ°é€šè®¯å½•é¡µé¢".to_string(),
                    });
                }
                Err(e) => {
                    warn!("å¯¼èˆªå¤±è´¥ (å°è¯• {}): {}", attempts, e);
                    if attempts < max_attempts {
                        sleep(Duration::from_secs(2)).await;
                    }
                }
            }
        }

        Ok(NavigationResult {
            success: false,
            message: format!("å¯¼èˆªå¤±è´¥ï¼Œå·²å°è¯• {} æ¬¡", max_attempts),
        })
    }

    /// å†…éƒ¨å¯¼èˆªé€»è¾‘
    async fn navigate_to_contacts_internal(&self) -> Result<()> {
        // ç‚¹å‡»å·¦ä¸Šè§’èœå•æŒ‰é’®
        self.adb_tap(49, 98).await?;
        sleep(Duration::from_secs(2)).await;

        // åœ¨ä¾§è¾¹æ ä¸­å¯»æ‰¾"å‘ç°å¥½å‹"æˆ–ç›¸å…³é€‰é¡¹
        // è¿™é‡Œä½¿ç”¨å›ºå®šåæ ‡ï¼Œå®é™…åº”ç”¨ä¸­å¯ä»¥é€šè¿‡UIåˆ†æè·å–
        self.adb_tap(200, 300).await?;
        sleep(Duration::from_secs(2)).await;

        // è¿›å…¥é€šè®¯å½•é¡µé¢
        self.adb_tap(200, 400).await?;
        sleep(Duration::from_secs(3)).await;

        Ok(())
    }

    /// å¯åŠ¨å°çº¢ä¹¦åº”ç”¨
    async fn open_xiaohongshu_app(&self) -> Result<()> {
        info!("å¯åŠ¨å°çº¢ä¹¦åº”ç”¨");

        let output = Command::new(&self.adb_path)
            .args(&[
                "-s",
                &self.device_id,
                "shell",
                "am",
                "start",
                "-n",
                "com.xingin.xhs/.activity.SplashActivity",
            ])
            .output()
            .context("å¯åŠ¨å°çº¢ä¹¦åº”ç”¨å¤±è´¥")?;

        if !output.status.success() {
            // å°è¯•å¤‡ç”¨å¯åŠ¨æ–¹å¼
            let output = Command::new(&self.adb_path)
                .args(&[
                    "-s",
                    &self.device_id,
                    "shell",
                    "monkey",
                    "-p",
                    "com.xingin.xhs",
                    "-c",
                    "android.intent.category.LAUNCHER",
                    "1",
                ])
                .output()
                .context("å¤‡ç”¨å¯åŠ¨æ–¹å¼å¤±è´¥")?;

            if !output.status.success() {
                return Err(anyhow::anyhow!("å¯åŠ¨å°çº¢ä¹¦åº”ç”¨å¤±è´¥"));
            }
        }

        Ok(())
    }

    /// æ‰§è¡Œå°çº¢ä¹¦è‡ªåŠ¨å…³æ³¨
    pub async fn auto_follow(
        &self,
        options: Option<XiaohongshuFollowOptions>,
    ) -> Result<XiaohongshuFollowResult> {
        let start_time = std::time::Instant::now();
        info!("å¼€å§‹å°çº¢ä¹¦è‡ªåŠ¨å…³æ³¨æµç¨‹");

        let opts = options.unwrap_or_default();
        let max_pages = opts.max_pages.unwrap_or(5);
        let follow_interval = opts.follow_interval.unwrap_or(2000);
        let skip_existing = opts.skip_existing.unwrap_or(true);
        let return_to_home = opts.return_to_home.unwrap_or(true);

        let mut total_followed = 0;
        let mut pages_processed = 0;
        let mut details = Vec::new();

        // ç¡®ä¿åœ¨é€šè®¯å½•é¡µé¢
        match self.navigate_to_contacts().await? {
            result if !result.success => {
                return Ok(XiaohongshuFollowResult {
                    success: false,
                    total_followed: 0,
                    pages_processed: 0,
                    duration: start_time.elapsed().as_secs(),
                    details: vec![],
                    message: "æ— æ³•å¯¼èˆªåˆ°é€šè®¯å½•é¡µé¢".to_string(),
                });
            }
            _ => {}
        }

        // å¼€å§‹æ‰¹é‡å…³æ³¨
        for page in 0..max_pages {
            pages_processed = page + 1;
            info!("å¤„ç†ç¬¬ {} é¡µ", pages_processed);

            // è·å–å½“å‰é¡µé¢çš„å…³æ³¨æŒ‰é’®
            let follow_buttons = self.find_follow_buttons().await?;

            if follow_buttons.is_empty() {
                info!("ç¬¬ {} é¡µæ²¡æœ‰æ‰¾åˆ°å…³æ³¨æŒ‰é’®", pages_processed);
                if page > 0 {
                    // å¦‚æœä¸æ˜¯ç¬¬ä¸€é¡µä¸”æ²¡æœ‰æŒ‰é’®ï¼Œå¯èƒ½å·²ç»åˆ°åº•äº†
                    break;
                }
                // å°è¯•æ»šåŠ¨åˆ°ä¸‹ä¸€é¡µ
                if page < max_pages - 1 {
                    self.scroll_down().await?;
                    sleep(Duration::from_millis(2000)).await;
                }
                continue;
            }

            info!("æ‰¾åˆ° {} ä¸ªå…³æ³¨æŒ‰é’®", follow_buttons.len());

            // é€ä¸ªç‚¹å‡»å…³æ³¨æŒ‰é’®
            for (_i, (x, y)) in follow_buttons.iter().enumerate() {
                let button_text_before = self
                    .get_button_text_at(*x, *y)
                    .await
                    .unwrap_or("å…³æ³¨".to_string());

                if skip_existing
                    && (button_text_before.contains("å·²å…³æ³¨")
                        || button_text_before.contains("following"))
                {
                    info!("è·³è¿‡å·²å…³æ³¨ç”¨æˆ· ({}, {})", x, y);
                    details.push(FollowDetail {
                        user_position: (*x, *y),
                        follow_success: false,
                        button_text_before: Some(button_text_before),
                        button_text_after: None,
                        error: Some("å·²å…³æ³¨ï¼Œè·³è¿‡".to_string()),
                    });
                    continue;
                }

                // ç‚¹å‡»å…³æ³¨æŒ‰é’®
                match self.click_follow_button(*x, *y).await {
                    Ok(true) => {
                        total_followed += 1;
                        let button_text_after = self
                            .get_button_text_at(*x, *y)
                            .await
                            .unwrap_or("å·²å…³æ³¨".to_string());

                        info!("æˆåŠŸå…³æ³¨ç”¨æˆ· #{}: ({}, {})", total_followed, x, y);
                        details.push(FollowDetail {
                            user_position: (*x, *y),
                            follow_success: true,
                            button_text_before: Some(button_text_before),
                            button_text_after: Some(button_text_after),
                            error: None,
                        });
                    }
                    Ok(false) => {
                        warn!("å…³æ³¨å¤±è´¥: ({}, {})", x, y);
                        details.push(FollowDetail {
                            user_position: (*x, *y),
                            follow_success: false,
                            button_text_before: Some(button_text_before),
                            button_text_after: None,
                            error: Some("ç‚¹å‡»å¤±è´¥".to_string()),
                        });
                    }
                    Err(e) => {
                        error!("å…³æ³¨å‡ºé”™: ({}, {}) - {}", x, y, e);
                        details.push(FollowDetail {
                            user_position: (*x, *y),
                            follow_success: false,
                            button_text_before: Some(button_text_before),
                            button_text_after: None,
                            error: Some(e.to_string()),
                        });
                    }
                }

                // å…³æ³¨é—´éš”
                sleep(Duration::from_millis(follow_interval)).await;
            }

            // æ»šåŠ¨åˆ°ä¸‹ä¸€é¡µ
            if pages_processed < max_pages {
                info!("æ»šåŠ¨åˆ°ä¸‹ä¸€é¡µ");
                self.scroll_down().await?;
                sleep(Duration::from_millis(2000)).await;
            }
        }

        // è¿”å›ä¸»é¡µ
        if return_to_home {
            info!("è¿”å›å°çº¢ä¹¦ä¸»é¡µ");
            if let Err(e) = self.return_to_home().await {
                warn!("è¿”å›ä¸»é¡µå¤±è´¥: {}", e);
            }
        }

        let duration = start_time.elapsed().as_secs();
        let success = total_followed > 0;

        info!(
            "è‡ªåŠ¨å…³æ³¨å®Œæˆ: å…³æ³¨ {} ä¸ªç”¨æˆ·ï¼Œå¤„ç† {} é¡µï¼Œè€—æ—¶ {}ç§’",
            total_followed, pages_processed, duration
        );

        Ok(XiaohongshuFollowResult {
            success,
            total_followed,
            pages_processed,
            duration,
            details,
            message: if success {
                format!("æˆåŠŸå…³æ³¨ {} ä¸ªç”¨æˆ·", total_followed)
            } else {
                "æœªå…³æ³¨ä»»ä½•ç”¨æˆ·".to_string()
            },
        })
    }

    /// æŸ¥æ‰¾é¡µé¢ä¸­çš„å…³æ³¨æŒ‰é’®åæ ‡
    async fn find_follow_buttons(&self) -> Result<Vec<(i32, i32)>> {
        // è·å–UI dump
        let ui_content = self.get_ui_dump().await?;

        // ç®€åŒ–çš„æŒ‰é’®æŸ¥æ‰¾é€»è¾‘
        // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œåº”è¯¥è§£æXMLå¹¶æŸ¥æ‰¾å…³æ³¨æŒ‰é’®çš„å‡†ç¡®ä½ç½®
        let mut buttons = Vec::new();

        // å‡è®¾çš„å…³æ³¨æŒ‰é’®ä½ç½®ï¼ˆåŸºäºUIåˆ†æï¼‰
        let possible_positions = vec![
            (960, 200), // ç¬¬ä¸€ä¸ªç”¨æˆ·çš„å…³æ³¨æŒ‰é’®
            (960, 350), // ç¬¬äºŒä¸ªç”¨æˆ·çš„å…³æ³¨æŒ‰é’®
            (960, 500), // ç¬¬ä¸‰ä¸ªç”¨æˆ·çš„å…³æ³¨æŒ‰é’®
            (960, 650), // ç¬¬å››ä¸ªç”¨æˆ·çš„å…³æ³¨æŒ‰é’®
        ];

        for (x, y) in possible_positions {
            // ç®€å•æ£€æŸ¥ï¼šå¦‚æœUIå†…å®¹åŒ…å«å…³æ³¨ç›¸å…³æ–‡æœ¬ï¼Œè®¤ä¸ºå­˜åœ¨æŒ‰é’®
            if ui_content.contains("å…³æ³¨") || ui_content.contains("follow") {
                buttons.push((x, y));
            }
        }

        Ok(buttons)
    }

    /// ç‚¹å‡»å…³æ³¨æŒ‰é’®
    async fn click_follow_button(&self, x: i32, y: i32) -> Result<bool> {
        // ç‚¹å‡»æŒ‰é’®
        self.adb_tap(x, y).await?;
        sleep(Duration::from_millis(500)).await;

        // ç®€åŒ–éªŒè¯ï¼šå‡è®¾ç‚¹å‡»æˆåŠŸ
        Ok(true)
    }

    /// è·å–æŒ‡å®šä½ç½®çš„æŒ‰é’®æ–‡æœ¬ï¼ˆç®€åŒ–å®ç°ï¼‰
    async fn get_button_text_at(&self, _x: i32, _y: i32) -> Result<String> {
        // ç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥é€šè¿‡UIåˆ†æè·å–å…·ä½“æŒ‰é’®æ–‡æœ¬
        Ok("å…³æ³¨".to_string())
    }

    /// è·å–UI dump
    async fn get_ui_dump(&self) -> Result<String> {
        let output = Command::new(&self.adb_path)
            .args(&[
                "-s",
                &self.device_id,
                "shell",
                "uiautomator",
                "dump",
                "/sdcard/xiaohongshu_ui.xml",
            ])
            .output()
            .context("è·å–UI dumpå¤±è´¥")?;

        if !output.status.success() {
            return Err(anyhow::anyhow!("UI dumpå¤±è´¥"));
        }

        // è¯»å–UIæ–‡ä»¶å†…å®¹
        let output = Command::new(&self.adb_path)
            .args(&[
                "-s",
                &self.device_id,
                "shell",
                "cat",
                "/sdcard/xiaohongshu_ui.xml",
            ])
            .output()
            .context("è¯»å–UIæ–‡ä»¶å¤±è´¥")?;

        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    }

    /// å‘ä¸‹æ»šåŠ¨é¡µé¢
    async fn scroll_down(&self) -> Result<()> {
        // ä»å±å¹•ä¸­é—´å‘ä¸Šæ»‘åŠ¨
        let output = Command::new(&self.adb_path)
            .args(&[
                "-s",
                &self.device_id,
                "shell",
                "input",
                "swipe",
                "500",
                "800", // èµ·å§‹ä½ç½®
                "500",
                "300",  // ç»“æŸä½ç½®
                "1000", // æ»‘åŠ¨æ—¶é•¿(ms)
            ])
            .output()
            .context("æ»‘åŠ¨é¡µé¢å¤±è´¥")?;

        if !output.status.success() {
            return Err(anyhow::anyhow!("æ»‘åŠ¨é¡µé¢å¤±è´¥"));
        }

        Ok(())
    }

    /// è¿”å›ä¸»é¡µ
    async fn return_to_home(&self) -> Result<()> {
        // ç‚¹å‡»è¿”å›æŒ‰é’®æˆ–æŒ‰Homeé”®
        let output = Command::new(&self.adb_path)
            .args(&[
                "-s",
                &self.device_id,
                "shell",
                "input",
                "keyevent",
                "KEYCODE_HOME",
            ])
            .output()
            .context("è¿”å›ä¸»é¡µå¤±è´¥")?;

        if !output.status.success() {
            return Err(anyhow::anyhow!("è¿”å›ä¸»é¡µå¤±è´¥"));
        }

        // å†æ¬¡å¯åŠ¨å°çº¢ä¹¦åˆ°ä¸»é¡µ
        sleep(Duration::from_millis(1000)).await;
        self.open_xiaohongshu_app().await?;

        Ok(())
    }

    /// æ‰§è¡Œå°çº¢ä¹¦è‡ªåŠ¨å…³æ³¨
    pub async fn auto_follow(&self, options: Option<XiaohongshuFollowOptions>) -> Result<XiaohongshuFollowResult> {
        let start_time = std::time::Instant::now();
        info!("å¼€å§‹å°çº¢ä¹¦è‡ªåŠ¨å…³æ³¨æµç¨‹");

        let opts = options.unwrap_or_default();
        let max_pages = opts.max_pages.unwrap_or(5);
        let follow_interval = opts.follow_interval.unwrap_or(2000);
        let skip_existing = opts.skip_existing.unwrap_or(true);
        let return_home = opts.return_to_home.unwrap_or(true);

        let mut total_followed = 0;
        let mut pages_processed = 0;
        let mut details = Vec::new();

        // ç¡®ä¿åœ¨é€šè®¯å½•é¡µé¢
        match self.navigate_to_contacts().await? {
            result if !result.success => {
                return Ok(XiaohongshuFollowResult {
                    success: false,
                    total_followed: 0,
                    pages_processed: 0,
                    duration: start_time.elapsed().as_secs(),
                    details: vec![],
                    message: "æ— æ³•å¯¼èˆªåˆ°é€šè®¯å½•é¡µé¢".to_string(),
                });
            }
            _ => {}
        }

        // æ‰¹é‡å…³æ³¨é€»è¾‘
        for page in 0..max_pages {
            pages_processed = page + 1;
            info!("å¤„ç†ç¬¬ {} é¡µ", pages_processed);

            // è·å–å½“å‰é¡µé¢çš„å…³æ³¨æŒ‰é’®
            let follow_buttons = self.find_follow_buttons().await?;

            if follow_buttons.is_empty() {
                info!("ç¬¬ {} é¡µæ²¡æœ‰æ‰¾åˆ°å…³æ³¨æŒ‰é’®", pages_processed);
                if page > 0 {
                    // å¦‚æœä¸æ˜¯ç¬¬ä¸€é¡µä¸”æ²¡æœ‰æŒ‰é’®ï¼Œå¯èƒ½å·²ç»åˆ°åº•äº†
                    break;
                }
                // å°è¯•æ»šåŠ¨åˆ°ä¸‹ä¸€é¡µ
                if page < max_pages - 1 {
                    self.scroll_down().await?;
                    sleep(Duration::from_millis(2000)).await;
                }
                continue;
            }

            info!("æ‰¾åˆ° {} ä¸ªå…³æ³¨æŒ‰é’®", follow_buttons.len());

            // é€ä¸ªç‚¹å‡»å…³æ³¨æŒ‰é’®
            for (i, (x, y)) in follow_buttons.iter().enumerate() {
                let button_text_before = self
                    .get_button_text_at(*x, *y)
                    .await
                    .unwrap_or("å…³æ³¨".to_string());

                if skip_existing
                    && (button_text_before.contains("å·²å…³æ³¨")
                        || button_text_before.contains("following"))
                {
                    info!("è·³è¿‡å·²å…³æ³¨ç”¨æˆ· ({}, {})", x, y);
                    details.push(FollowDetail {
                        user_position: (*x, *y),
                        follow_success: false,
                        button_text_before: Some(button_text_before),
                        button_text_after: None,
                        error: Some("å·²å…³æ³¨ï¼Œè·³è¿‡".to_string()),
                    });
                    continue;
                }

                // ç‚¹å‡»å…³æ³¨æŒ‰é’®
                match self.click_follow_button(*x, *y).await {
                    Ok(true) => {
                        total_followed += 1;
                        let button_text_after = self
                            .get_button_text_at(*x, *y)
                            .await
                            .unwrap_or("å·²å…³æ³¨".to_string());

                        info!("æˆåŠŸå…³æ³¨ç”¨æˆ· #{}: ({}, {})", total_followed, x, y);
                        details.push(FollowDetail {
                            user_position: (*x, *y),
                            follow_success: true,
                            button_text_before: Some(button_text_before),
                            button_text_after: Some(button_text_after),
                            error: None,
                        });
                    }
                    Ok(false) => {
                        warn!("å…³æ³¨å¤±è´¥: ({}, {})", x, y);
                        details.push(FollowDetail {
                            user_position: (*x, *y),
                            follow_success: false,
                            button_text_before: Some(button_text_before),
                            button_text_after: None,
                            error: Some("ç‚¹å‡»å¤±è´¥".to_string()),
                        });
                    }
                    Err(e) => {
                        error!("å…³æ³¨å‡ºé”™: ({}, {}) - {}", x, y, e);
                        details.push(FollowDetail {
                            user_position: (*x, *y),
                            follow_success: false,
                            button_text_before: Some(button_text_before),
                            button_text_after: None,
                            error: Some(e.to_string()),
                        });
                    }
                }

                // å…³æ³¨é—´éš”
                sleep(Duration::from_millis(follow_interval)).await;
            }

            // æ»šåŠ¨åˆ°ä¸‹ä¸€é¡µ
            if pages_processed < max_pages {
                info!("æ»šåŠ¨åˆ°ä¸‹ä¸€é¡µ");
                self.scroll_down().await?;
                sleep(Duration::from_millis(2000)).await;
            }
        }

        // è¿”å›ä¸»é¡µ
        if return_home {
            info!("è¿”å›å°çº¢ä¹¦ä¸»é¡µ");
            if let Err(e) = self.return_to_home().await {
                warn!("è¿”å›ä¸»é¡µå¤±è´¥: {}", e);
            }
        }

        let duration = start_time.elapsed().as_secs();
        let success = total_followed > 0;

        info!(
            "è‡ªåŠ¨å…³æ³¨å®Œæˆ: å…³æ³¨ {} ä¸ªç”¨æˆ·ï¼Œå¤„ç† {} é¡µï¼Œè€—æ—¶ {}ç§’",
            total_followed, pages_processed, duration
        );

        Ok(XiaohongshuFollowResult {
            success,
            total_followed,
            pages_processed,
            duration,
            details,
            message: if success {
                format!("æˆåŠŸå…³æ³¨ {} ä¸ªç”¨æˆ·", total_followed)
            } else {
                "æœªå…³æ³¨ä»»ä½•ç”¨æˆ·".to_string()
            },
        })
    }

    /// ç‚¹å‡»å…³æ³¨æŒ‰é’®
    async fn click_follow_button(&self, x: i32, y: i32) -> Result<bool> {
        info!("ç‚¹å‡»å…³æ³¨æŒ‰é’® åæ ‡:({}, {})", x, y);

        self.adb_tap(x, y).await?;
        sleep(Duration::from_millis(1000)).await;

        // éªŒè¯ç‚¹å‡»æ•ˆæœ - ç®€åŒ–ç‰ˆæœ¬
        // å®é™…åº”è¯¥é€šè¿‡UI dumpéªŒè¯æŒ‰é’®çŠ¶æ€å˜åŒ–
        Ok(true)
    }

    /// è·å–æŒ‡å®šä½ç½®çš„æŒ‰é’®æ–‡æœ¬ï¼ˆç®€åŒ–å®ç°ï¼‰
    async fn get_button_text_at(&self, _x: i32, _y: i32) -> Result<String> {
        // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥é€šè¿‡UI dumpè§£æç‰¹å®šä½ç½®çš„æ–‡æœ¬
        Ok("å…³æ³¨".to_string())
    }

    /// æ»šåŠ¨é¡µé¢å‘ä¸‹
    async fn scroll_down(&self) -> Result<()> {
        info!("å‘ä¸‹æ»šåŠ¨é¡µé¢");

        let _output = Command::new(&self.adb_path)
            .args(&[
                "-s", &self.device_id,
                "shell", "input", "swipe",
                "500", "800", "500", "300", "1000"
            ])
            .output()
            .context("æ»šåŠ¨é¡µé¢å¤±è´¥")?;

        Ok(())
    }

    /// ADBç‚¹å‡»åæ ‡
    async fn adb_tap(&self, x: i32, y: i32) -> Result<()> {
        let output = Command::new(&self.adb_path)
            .args(&[
                "-s",
                &self.device_id,
                "shell",
                "input",
                "tap",
                &x.to_string(),
                &y.to_string(),
            ])
            .output()
            .context("ADBç‚¹å‡»å¤±è´¥")?;

        if !output.status.success() {
            return Err(anyhow::anyhow!("ADBç‚¹å‡»å¤±è´¥"));
        }

        Ok(())
    }
}
