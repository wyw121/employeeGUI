# å°çº¢ä¹¦å…³æ³¨è„šæœ¬æ ¸å¿ƒé€»è¾‘æå–æ–‡æ¡£

## ğŸ“‹ é¡¹ç›®æ¦‚è¿°

æœ¬æ–‡æ¡£æå–äº†å°çº¢ä¹¦å…³æ³¨è„šæœ¬çš„æ ¸å¿ƒé€»è¾‘ï¼Œé‡ç‚¹å…³æ³¨é€šè®¯å½•å¥½å‹è‡ªåŠ¨å…³æ³¨çš„å…·ä½“å®ç°ï¼Œç”¨äºé›†æˆåˆ°GUIæ¡Œé¢ç¨‹åºä¸­ã€‚

### ğŸ¯ æ ¸å¿ƒåŠŸèƒ½
- å°çº¢ä¹¦åº”ç”¨çŠ¶æ€æ£€æŸ¥
- æ™ºèƒ½é¡µé¢è¯†åˆ«ä¸å¯¼èˆª
- é€šè®¯å½•å¥½å‹æ‰¹é‡è‡ªåŠ¨å…³æ³¨
- UIè‡ªåŠ¨åŒ–æ“ä½œä¸é”™è¯¯å¤„ç†

---

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„

### æ ¸å¿ƒç»„ä»¶

#### 1. XiaohongshuAutomator ä¸»æ§åˆ¶å™¨
```rust
pub struct XiaohongshuAutomator {
    device_id: String,    // Androidè®¾å¤‡ID
    adb_path: String,     // ADBå‘½ä»¤è·¯å¾„
}
```

#### 2. æ•°æ®ç»“æ„å®šä¹‰
```rust
// åº”ç”¨çŠ¶æ€æ£€æŸ¥ç»“æœ
pub struct AppStatusResult {
    pub app_installed: bool,
    pub app_running: bool,
    pub message: String,
}

// å¯¼èˆªæ“ä½œç»“æœ
pub struct NavigationResult {
    pub success: bool,
    pub message: String,
}

// å…³æ³¨æ“ä½œé…ç½®
pub struct XiaohongshuFollowOptions {
    pub max_pages: Option<usize>,           // æœ€å¤§å¤„ç†é¡µæ•°
    pub follow_interval: Option<u64>,       // å…³æ³¨é—´éš”(æ¯«ç§’)
    pub skip_existing: Option<bool>,        // è·³è¿‡å·²å…³æ³¨ç”¨æˆ·
    pub return_to_home: Option<bool>,       // å®Œæˆåè¿”å›ä¸»é¡µ
}

// å…³æ³¨æ“ä½œç»“æœ
pub struct XiaohongshuFollowResult {
    pub success: bool,
    pub total_followed: usize,
    pub pages_processed: usize,
    pub duration: u64,
    pub details: Vec<FollowDetail>,
    pub message: String,
}

// é¡µé¢çŠ¶æ€æšä¸¾
pub enum PageState {
    Unknown,         // æœªçŸ¥é¡µé¢
    MainPage,        // å°çº¢ä¹¦ä¸»é¡µ
    SidebarOpen,     // ä¾§è¾¹æ å·²æ‰“å¼€
    DiscoverFriends, // å‘ç°å¥½å‹é¡µé¢
    ContactsList,    // é€šè®¯å½•åˆ—è¡¨é¡µé¢
    UserProfile,     // ç”¨æˆ·èµ„æ–™é¡µé¢
}
```

---

## ğŸ”§ æ ¸å¿ƒAPIæ¥å£

### 1. åº”ç”¨çŠ¶æ€æ£€æŸ¥
```rust
/// æ£€æŸ¥å°çº¢ä¹¦åº”ç”¨çŠ¶æ€
pub async fn check_app_status(&self) -> Result<AppStatusResult> {
    info!("æ£€æŸ¥å°çº¢ä¹¦åº”ç”¨çŠ¶æ€...");
    
    let app_installed = self.is_app_installed("com.xingin.xhs").await?;
    let app_running = if app_installed {
        self.is_app_running("com.xingin.xhs").await?
    } else {
        false
    };
    
    let message = match (app_installed, app_running) {
        (false, _) => "å°çº¢ä¹¦åº”ç”¨æœªå®‰è£…".to_string(),
        (true, false) => "å°çº¢ä¹¦åº”ç”¨å·²å®‰è£…ä½†æœªè¿è¡Œ".to_string(),
        (true, true) => "å°çº¢ä¹¦åº”ç”¨å·²å®‰è£…ä¸”æ­£åœ¨è¿è¡Œ".to_string(),
    };
    
    Ok(AppStatusResult {
        app_installed,
        app_running,
        message,
    })
}
```

### 2. æ™ºèƒ½é¡µé¢è¯†åˆ«
```rust
/// æ™ºèƒ½é¡µé¢è¯†åˆ«
pub async fn recognize_current_page(&self) -> Result<PageRecognitionResult> {
    info!("ğŸ” å¼€å§‹è¯†åˆ«å½“å‰é¡µé¢çŠ¶æ€...");
    
    let ui_dump = self.get_ui_dump().await?;
    let ui_elements = self.parse_ui_elements(&ui_dump).await?;
    
    // åˆ†æé¡µé¢ç‰¹å¾
    let (page_state, confidence, key_elements) = self.analyze_page_state(&ui_dump, &ui_elements).await?;
    
    Ok(PageRecognitionResult {
        current_state: page_state,
        confidence,
        key_elements,
        ui_elements,
        message: format!("è¯†åˆ«åˆ°é¡µé¢: {:?}, ä¿¡å¿ƒåº¦: {:.2}", page_state, confidence),
    })
}
```

### 3. å¯¼èˆªåˆ°é€šè®¯å½•é¡µé¢
```rust
/// å¯¼èˆªåˆ°å°çº¢ä¹¦é€šè®¯å½•é¡µé¢ï¼ˆåŸºäºæ‰‹åŠ¨éªŒè¯çš„æµç¨‹ï¼‰
pub async fn navigate_to_contacts(&self) -> Result<NavigationResult> {
    info!("ğŸ§­ åŸºäºæ‰‹åŠ¨éªŒè¯æµç¨‹å¯¼èˆªåˆ°å°çº¢ä¹¦é€šè®¯å½•é¡µé¢...");
    
    // æ­¥éª¤1: ç¡®ä¿åº”ç”¨è¿è¡ŒçŠ¶æ€
    let app_status = self.check_app_status().await?;
    if !app_status.app_installed {
        return Ok(NavigationResult {
            success: false,
            message: "å°çº¢ä¹¦åº”ç”¨æœªå®‰è£…".to_string(),
        });
    }
    
    if !app_status.app_running {
        info!("å¯åŠ¨å°çº¢ä¹¦åº”ç”¨...");
        self.open_xiaohongshu_app().await?;
        sleep(Duration::from_secs(3)).await;
    }
    
    // æ­¥éª¤2: ç‚¹å‡»å¤´åƒæ‰“å¼€ä¾§è¾¹æ ï¼ˆåæ ‡: 60, 100ï¼‰
    info!("ğŸ“± æ­¥éª¤1: ç‚¹å‡»å¤´åƒæ‰“å¼€ä¾§è¾¹æ ");
    self.adb_tap(60, 100).await?;
    sleep(Duration::from_secs(2)).await;
    
    // æ­¥éª¤3: éªŒè¯ä¾§è¾¹æ çŠ¶æ€å¹¶ç‚¹å‡»å‘ç°å¥½å‹
    let sidebar_check = self.recognize_current_page().await?;
    if matches!(sidebar_check.current_state, PageState::SidebarOpen) {
        info!("ğŸ‘¥ æ­¥éª¤2: ç‚¹å‡»å‘ç°å¥½å‹é€‰é¡¹");
        let discover_coords = self.find_discover_friends_coords().await?;
        self.adb_tap(discover_coords.0, discover_coords.1).await?;
        sleep(Duration::from_secs(2)).await;
        
        // æ­¥éª¤4: ç‚¹å‡»é€šè®¯å½•æœ‹å‹é€‰é¡¹
        info!("ğŸ“‹ æ­¥éª¤3: ç‚¹å‡»é€šè®¯å½•æœ‹å‹é€‰é¡¹");
        let contacts_coords = self.find_contacts_option_coords().await?;
        self.adb_tap(contacts_coords.0, contacts_coords.1).await?;
        sleep(Duration::from_secs(3)).await;
        
        Ok(NavigationResult {
            success: true,
            message: "æˆåŠŸå¯¼èˆªåˆ°é€šè®¯å½•é¡µé¢".to_string(),
        })
    } else {
        Ok(NavigationResult {
            success: false,
            message: "ä¾§è¾¹æ æ‰“å¼€å¤±è´¥".to_string(),
        })
    }
}
```

### 4. æ‰¹é‡è‡ªåŠ¨å…³æ³¨
```rust
/// æ‰§è¡Œå°çº¢ä¹¦è‡ªåŠ¨å…³æ³¨
pub async fn auto_follow(&self, options: Option<XiaohongshuFollowOptions>) -> Result<XiaohongshuFollowResult> {
    let start_time = std::time::Instant::now();
    info!("å¼€å§‹å°çº¢ä¹¦è‡ªåŠ¨å…³æ³¨æµç¨‹");
    
    let opts = options.unwrap_or_default();
    let max_pages = opts.max_pages.unwrap_or(5);
    let follow_interval = opts.follow_interval.unwrap_or(2000);
    let skip_existing = opts.skip_existing.unwrap_or(true);
    
    let mut total_followed = 0;
    let mut pages_processed = 0;
    let mut details = Vec::new();
    
    // ç¡®ä¿åœ¨é€šè®¯å½•é¡µé¢
    match self.navigate_to_contacts().await? {
        result if !result.success => {
            return Ok(XiaohongshuFollowResult {
                success: false,
                total_followed: 0,
                pages_processed: 0,
                duration: start_time.elapsed().as_secs(),
                details: vec![],
                message: "æ— æ³•å¯¼èˆªåˆ°é€šè®¯å½•é¡µé¢".to_string(),
            });
        }
        _ => {}
    }
    
    // æ‰¹é‡å…³æ³¨é€»è¾‘
    for page in 0..max_pages {
        pages_processed = page + 1;
        info!("å¤„ç†ç¬¬ {} é¡µ", pages_processed);
        
        // è·å–å½“å‰é¡µé¢çš„å…³æ³¨æŒ‰é’®
        let follow_buttons = self.find_follow_buttons().await?;
        
        if follow_buttons.is_empty() {
            if page > 0 { break; } // å¯èƒ½å·²ç»åˆ°åº•äº†
            if page < max_pages - 1 {
                self.scroll_down().await?;
                sleep(Duration::from_millis(2000)).await;
            }
            continue;
        }
        
        // é€ä¸ªç‚¹å‡»å…³æ³¨æŒ‰é’®
        for (x, y) in follow_buttons.iter() {
            let button_text_before = self.get_button_text_at(*x, *y).await.unwrap_or("å…³æ³¨".to_string());
            
            if skip_existing && (button_text_before.contains("å·²å…³æ³¨") || button_text_before.contains("following")) {
                info!("è·³è¿‡å·²å…³æ³¨ç”¨æˆ· ({}, {})", x, y);
                continue;
            }
            
            // ç‚¹å‡»å…³æ³¨æŒ‰é’®
            match self.click_follow_button(*x, *y).await {
                Ok(true) => {
                    total_followed += 1;
                    info!("æˆåŠŸå…³æ³¨ç”¨æˆ· #{}: ({}, {})", total_followed, x, y);
                }
                Ok(false) => {
                    warn!("å…³æ³¨å¤±è´¥: ({}, {})", x, y);
                }
                Err(e) => {
                    error!("å…³æ³¨å‡ºé”™: ({}, {}) - {}", x, y, e);
                }
            }
            
            // å…³æ³¨é—´éš”
            sleep(Duration::from_millis(follow_interval)).await;
        }
        
        // æ»šåŠ¨åˆ°ä¸‹ä¸€é¡µ
        if pages_processed < max_pages {
            self.scroll_down().await?;
            sleep(Duration::from_millis(2000)).await;
        }
    }
    
    let duration = start_time.elapsed().as_secs();
    let success = total_followed > 0;
    
    Ok(XiaohongshuFollowResult {
        success,
        total_followed,
        pages_processed,
        duration,
        details,
        message: if success {
            format!("æˆåŠŸå…³æ³¨ {} ä¸ªç”¨æˆ·", total_followed)
        } else {
            "æœªå…³æ³¨ä»»ä½•ç”¨æˆ·".to_string()
        },
    })
}
```

---

## ğŸ” UIè‡ªåŠ¨åŒ–æ ¸å¿ƒæ–¹æ³•

### 1. UI Dumpè·å–
```rust
/// è·å–UI dump
async fn get_ui_dump(&self) -> Result<String> {
    // æ–¹æ³•1: ç›´æ¥è¾“å‡ºåˆ°stdout
    let output1 = Command::new(&self.adb_path)
        .args(&["-s", &self.device_id, "shell", "uiautomator", "dump", "/dev/stdout"])
        .output()
        .context("è·å–UI dumpå¤±è´¥")?;
    
    let result1 = String::from_utf8_lossy(&output1.stdout).to_string();
    
    if result1.len() > 100 && result1.contains("<?xml") {
        return Ok(result1);
    }
    
    // æ–¹æ³•2: å…ˆdumpåˆ°æ–‡ä»¶ï¼Œå†cat
    let _dump_output = Command::new(&self.adb_path)
        .args(&["-s", &self.device_id, "shell", "uiautomator", "dump", "/sdcard/ui_dump.xml"])
        .output()
        .context("dumpåˆ°æ–‡ä»¶å¤±è´¥")?;
    
    let output2 = Command::new(&self.adb_path)
        .args(&["-s", &self.device_id, "shell", "cat", "/sdcard/ui_dump.xml"])
        .output()
        .context("è¯»å–UI dumpæ–‡ä»¶å¤±è´¥")?;
    
    let result2 = String::from_utf8_lossy(&output2.stdout).to_string();
    
    if result2.len() > 100 && result2.contains("<?xml") {
        return Ok(result2);
    }
    
    anyhow::bail!("æ— æ³•è·å–æœ‰æ•ˆçš„UI dump");
}
```

### 2. æ™ºèƒ½æŒ‰é’®æŸ¥æ‰¾
```rust
/// æ™ºèƒ½æŸ¥æ‰¾å…³æ³¨æŒ‰é’®
async fn find_follow_buttons(&self) -> Result<Vec<(i32, i32)>> {
    info!("ğŸ” æ™ºèƒ½åˆ†æé¡µé¢ä¸­çš„å…³æ³¨æŒ‰é’®...");
    
    let page_recognition = self.recognize_current_page().await?;
    
    if page_recognition.current_state != PageState::ContactsList {
        warn!("âš ï¸ å½“å‰ä¸åœ¨é€šè®¯å½•é¡µé¢ï¼ŒçŠ¶æ€: {:?}", page_recognition.current_state);
        return Ok(vec![]);
    }
    
    let mut buttons = Vec::new();
    
    // ä»UIå…ƒç´ ä¸­æŸ¥æ‰¾å…³æ³¨æŒ‰é’®
    for element in &page_recognition.ui_elements {
        if element.element_type == UIElementType::Button && element.clickable {
            let button_text = element.text.to_lowercase();
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯å…³æ³¨ç›¸å…³æŒ‰é’®
            if button_text.contains("å…³æ³¨") || button_text.contains("follow") || 
               button_text.contains("å·²å…³æ³¨") || button_text.contains("following") {
                
                let center_x = (element.bounds.0 + element.bounds.2) / 2;
                let center_y = (element.bounds.1 + element.bounds.3) / 2;
                
                buttons.push((center_x, center_y));
                info!("âœ… æ‰¾åˆ°å…³æ³¨æŒ‰é’® åæ ‡:({}, {}) æ–‡æœ¬:'{}'", center_x, center_y, element.text);
            }
        }
    }
    
    // å¦‚æœé€šè¿‡UIå…ƒç´ æ²¡æ‰¾åˆ°ï¼Œå°è¯•é€šè¿‡UI dumpçš„æ–‡æœ¬å®šä½
    if buttons.is_empty() {
        info!("ğŸ”„ UIå…ƒç´ åˆ†ææœªæ‰¾åˆ°æŒ‰é’®ï¼Œå°è¯•æ–‡æœ¬å®šä½...");
        buttons = self.find_buttons_by_text_pattern().await?;
    }
    
    info!("ğŸ“Š æ€»å…±æ‰¾åˆ° {} ä¸ªå…³æ³¨æŒ‰é’®ä½ç½®", buttons.len());
    Ok(buttons)
}
```

### 3. ADBå‘½ä»¤æ“ä½œ
```rust
/// ADBç‚¹å‡»åæ ‡
async fn adb_tap(&self, x: i32, y: i32) -> Result<()> {
    let _output = Command::new(&self.adb_path)
        .args(&[
            "-s", &self.device_id,
            "shell", "input", "tap",
            &x.to_string(), &y.to_string()
        ])
        .output()
        .context("ADBç‚¹å‡»å¤±è´¥")?;
    
    Ok(())
}

/// æ»šåŠ¨é¡µé¢å‘ä¸‹
async fn scroll_down(&self) -> Result<()> {
    info!("å‘ä¸‹æ»šåŠ¨é¡µé¢");
    
    let _output = Command::new(&self.adb_path)
        .args(&[
            "-s", &self.device_id,
            "shell", "input", "swipe",
            "500", "800", "500", "300", "1000"
        ])
        .output()
        .context("æ»šåŠ¨é¡µé¢å¤±è´¥")?;
    
    Ok(())
}

/// å¯åŠ¨å°çº¢ä¹¦åº”ç”¨
async fn open_xiaohongshu_app(&self) -> Result<()> {
    info!("å¯åŠ¨å°çº¢ä¹¦åº”ç”¨...");
    
    let _output = Command::new(&self.adb_path)
        .args(&[
            "-s", &self.device_id,
            "shell", "am", "start",
            "-n", "com.xingin.xhs/.index.v2.IndexActivityV2"
        ])
        .output()
        .context("å¯åŠ¨å°çº¢ä¹¦åº”ç”¨å¤±è´¥")?;
    
    sleep(Duration::from_secs(3)).await;
    Ok(())
}
```

---

## ğŸš€ GUIé›†æˆæ–¹æ¡ˆ

### 1. Tauriåç«¯é›†æˆ

åœ¨ `src-tauri/src/` ä¸­åˆ›å»º `xiaohongshu_service.rs`:

```rust
use anyhow::Result;
use serde::{Deserialize, Serialize};
use tauri::State;
use tokio::sync::Mutex;

// é›†æˆæ ¸å¿ƒè‡ªåŠ¨åŒ–ç»“æ„ä½“
pub struct XiaohongshuService {
    automator: Option<XiaohongshuAutomator>,
}

impl XiaohongshuService {
    pub fn new() -> Self {
        Self { automator: None }
    }
    
    pub fn initialize(&mut self, device_id: String) {
        self.automator = Some(XiaohongshuAutomator::new(device_id));
    }
}

// Tauriå‘½ä»¤å®šä¹‰
#[tauri::command]
pub async fn check_xiaohongshu_status(
    service: State<'_, Mutex<XiaohongshuService>>,
) -> Result<AppStatusResult, String> {
    let service = service.lock().await;
    
    if let Some(automator) = &service.automator {
        automator.check_app_status().await.map_err(|e| e.to_string())
    } else {
        Err("æœåŠ¡æœªåˆå§‹åŒ–".to_string())
    }
}

#[tauri::command]
pub async fn navigate_to_contacts_page(
    service: State<'_, Mutex<XiaohongshuService>>,
) -> Result<NavigationResult, String> {
    let service = service.lock().await;
    
    if let Some(automator) = &service.automator {
        automator.navigate_to_contacts().await.map_err(|e| e.to_string())
    } else {
        Err("æœåŠ¡æœªåˆå§‹åŒ–".to_string())
    }
}

#[tauri::command]
pub async fn auto_follow_contacts(
    service: State<'_, Mutex<XiaohongshuService>>,
    options: Option<XiaohongshuFollowOptions>,
) -> Result<XiaohongshuFollowResult, String> {
    let service = service.lock().await;
    
    if let Some(automator) = &service.automator {
        automator.auto_follow(options).await.map_err(|e| e.to_string())
    } else {
        Err("æœåŠ¡æœªåˆå§‹åŒ–".to_string())
    }
}

#[tauri::command]
pub async fn initialize_xiaohongshu_service(
    service: State<'_, Mutex<XiaohongshuService>>,
    device_id: String,
) -> Result<(), String> {
    let mut service = service.lock().await;
    service.initialize(device_id);
    Ok(())
}
```

### 2. å‰ç«¯React/TypeScripté›†æˆ

åœ¨ `src/services/xiaohongshuService.ts` ä¸­åˆ›å»ºæœåŠ¡ï¼š

```typescript
import { invoke } from '@tauri-apps/api/tauri';

export interface AppStatusResult {
  app_installed: boolean;
  app_running: boolean;
  message: string;
}

export interface NavigationResult {
  success: boolean;
  message: string;
}

export interface XiaohongshuFollowOptions {
  max_pages?: number;
  follow_interval?: number;
  skip_existing?: boolean;
  return_to_home?: boolean;
}

export interface XiaohongshuFollowResult {
  success: boolean;
  total_followed: number;
  pages_processed: number;
  duration: number;
  details: FollowDetail[];
  message: string;
}

export interface FollowDetail {
  user_position: [number, number];
  follow_success: boolean;
  button_text_before?: string;
  button_text_after?: string;
  error?: string;
}

export class XiaohongshuService {
  
  static async initializeService(deviceId: string): Promise<void> {
    return invoke('initialize_xiaohongshu_service', { deviceId });
  }
  
  static async checkAppStatus(): Promise<AppStatusResult> {
    return invoke('check_xiaohongshu_status');
  }
  
  static async navigateToContacts(): Promise<NavigationResult> {
    return invoke('navigate_to_contacts_page');
  }
  
  static async autoFollowContacts(
    options?: XiaohongshuFollowOptions
  ): Promise<XiaohongshuFollowResult> {
    return invoke('auto_follow_contacts', { options });
  }
  
  // å®Œæ•´å·¥ä½œæµç¨‹
  static async executeCompleteWorkflow(
    deviceId: string,
    options?: XiaohongshuFollowOptions
  ): Promise<{
    initialization: boolean;
    appStatus: AppStatusResult;
    navigation: NavigationResult;
    followResult: XiaohongshuFollowResult;
  }> {
    try {
      // 1. åˆå§‹åŒ–æœåŠ¡
      await this.initializeService(deviceId);
      
      // 2. æ£€æŸ¥åº”ç”¨çŠ¶æ€
      const appStatus = await this.checkAppStatus();
      
      // 3. å¯¼èˆªåˆ°é€šè®¯å½•é¡µé¢
      const navigation = await this.navigateToContacts();
      
      // 4. æ‰§è¡Œè‡ªåŠ¨å…³æ³¨
      const followResult = await this.autoFollowContacts(options);
      
      return {
        initialization: true,
        appStatus,
        navigation,
        followResult,
      };
    } catch (error) {
      throw new Error(`å·¥ä½œæµç¨‹æ‰§è¡Œå¤±è´¥: ${error}`);
    }
  }
}
```

### 3. Reactç»„ä»¶é›†æˆç¤ºä¾‹

```tsx
import React, { useState } from 'react';
import { XiaohongshuService, XiaohongshuFollowOptions } from '../services/xiaohongshuService';

export const XiaohongshuFollowComponent: React.FC = () => {
  const [deviceId, setDeviceId] = useState('emulator-5554');
  const [isLoading, setIsLoading] = useState(false);
  const [result, setResult] = useState<any>(null);
  const [options, setOptions] = useState<XiaohongshuFollowOptions>({
    max_pages: 5,
    follow_interval: 2000,
    skip_existing: true,
    return_to_home: true,
  });

  const handleExecuteWorkflow = async () => {
    setIsLoading(true);
    try {
      const result = await XiaohongshuService.executeCompleteWorkflow(deviceId, options);
      setResult(result);
      
      if (result.followResult.success) {
        alert(`æˆåŠŸå…³æ³¨äº† ${result.followResult.total_followed} ä¸ªå¥½å‹ï¼`);
      } else {
        alert(`å…³æ³¨å¤±è´¥: ${result.followResult.message}`);
      }
    } catch (error) {
      alert(`æ‰§è¡Œå¤±è´¥: ${error}`);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="xiaohongshu-follow-component">
      <h2>å°çº¢ä¹¦è‡ªåŠ¨å…³æ³¨</h2>
      
      <div className="device-config">
        <label>
          è®¾å¤‡ID:
          <input 
            type="text" 
            value={deviceId}
            onChange={(e) => setDeviceId(e.target.value)}
          />
        </label>
      </div>

      <div className="follow-options">
        <label>
          æœ€å¤§é¡µæ•°:
          <input 
            type="number" 
            value={options.max_pages}
            onChange={(e) => setOptions({...options, max_pages: parseInt(e.target.value)})}
          />
        </label>
        
        <label>
          å…³æ³¨é—´éš”(æ¯«ç§’):
          <input 
            type="number" 
            value={options.follow_interval}
            onChange={(e) => setOptions({...options, follow_interval: parseInt(e.target.value)})}
          />
        </label>
        
        <label>
          <input 
            type="checkbox" 
            checked={options.skip_existing}
            onChange={(e) => setOptions({...options, skip_existing: e.target.checked})}
          />
          è·³è¿‡å·²å…³æ³¨ç”¨æˆ·
        </label>
      </div>

      <button 
        onClick={handleExecuteWorkflow}
        disabled={isLoading}
        className="execute-button"
      >
        {isLoading ? 'æ‰§è¡Œä¸­...' : 'å¼€å§‹è‡ªåŠ¨å…³æ³¨'}
      </button>

      {result && (
        <div className="result-display">
          <h3>æ‰§è¡Œç»“æœ</h3>
          <pre>{JSON.stringify(result, null, 2)}</pre>
        </div>
      )}
    </div>
  );
};
```

---

## ğŸ“ é›†æˆæ­¥éª¤æ€»ç»“

### 1. ä¾èµ–æ·»åŠ 
åœ¨ `Cargo.toml` ä¸­æ·»åŠ ï¼š
```toml
[dependencies]
anyhow = "1.0"
tokio = { version = "1.0", features = ["full"] }
tracing = "0.1"
serde = { version = "1.0", features = ["derive"] }
```

### 2. æ ¸å¿ƒæ–‡ä»¶æ‹·è´
- å¤åˆ¶ `xiaohongshu_automator.rs` åˆ° `src-tauri/src/services/`
- å¤åˆ¶ `types.rs` åˆ° `src-tauri/src/`
- åˆ›å»º `xiaohongshu_service.rs` åŒ…è£…å™¨

### 3. Taurié…ç½®
åœ¨ `main.rs` ä¸­æ³¨å†Œå‘½ä»¤ï¼š
```rust
fn main() {
    tauri::Builder::default()
        .manage(Mutex::new(XiaohongshuService::new()))
        .invoke_handler(tauri::generate_handler![
            initialize_xiaohongshu_service,
            check_xiaohongshu_status,
            navigate_to_contacts_page,
            auto_follow_contacts,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}
```

### 4. å‰ç«¯é›†æˆ
- åˆ›å»ºTypeScriptæœåŠ¡ç±»
- åˆ›å»ºReactç»„ä»¶
- æ·»åŠ UIç•Œé¢å’Œäº¤äº’é€»è¾‘

---

## âš ï¸ é‡è¦æ³¨æ„äº‹é¡¹

### ç¯å¢ƒè¦æ±‚
- Windowsç³»ç»Ÿ
- ADBå·¥å…·å·²å®‰è£…å¹¶é…ç½®
- Androidè®¾å¤‡/æ¨¡æ‹Ÿå™¨å·²è¿æ¥
- å°çº¢ä¹¦åº”ç”¨å·²å®‰è£…ä¸”å·²ç™»å½•

### å…³é”®åæ ‡ï¼ˆåŸºäºæµ‹è¯•éªŒè¯ï¼‰
- å¤´åƒæŒ‰é’®: (60, 100)
- å‘ç°å¥½å‹é€‰é¡¹: (270, 168)
- é€šè®¯å½•é€‰é¡¹: (194, 205)
- æ»šåŠ¨åŒºåŸŸ: (500, 800) -> (500, 300)

### å®‰å…¨è€ƒè™‘
- é»˜è®¤2ç§’å…³æ³¨é—´éš”ï¼Œé¿å…è¢«æ£€æµ‹
- è·³è¿‡å·²å…³æ³¨ç”¨æˆ·ï¼Œé¿å…é‡å¤æ“ä½œ
- å®Œå–„çš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
- è¯¦ç»†çš„æ“ä½œæ—¥å¿—è®°å½•

### æ‰©å±•æ€§
- å¯é…ç½®çš„æ“ä½œå‚æ•°
- æ¨¡å—åŒ–çš„ä»£ç ç»“æ„
- æ”¯æŒå¤šè®¾å¤‡å¹¶è¡Œæ“ä½œ
- æ˜“äºé›†æˆåˆ°ä¸åŒUIæ¡†æ¶

---

## ğŸ¯ æ€»ç»“

æœ¬æ–‡æ¡£æå–äº†å°çº¢ä¹¦å…³æ³¨è„šæœ¬çš„æ ¸å¿ƒé€»è¾‘ï¼ŒåŒ…æ‹¬ï¼š

1. **å®Œæ•´çš„æ•°æ®ç»“æ„å®šä¹‰** - æ”¯æŒå„ç§æ“ä½œç»“æœå’Œé…ç½®
2. **æ ¸å¿ƒAPIæ¥å£** - æä¾›çŠ¶æ€æ£€æŸ¥ã€å¯¼èˆªã€å…³æ³¨ç­‰åŠŸèƒ½
3. **UIè‡ªåŠ¨åŒ–æ–¹æ³•** - åŸºäºADBå’Œuiautomatorçš„è®¾å¤‡æ§åˆ¶
4. **GUIé›†æˆæ–¹æ¡ˆ** - è¯¦ç»†çš„Tauri + Reacté›†æˆç¤ºä¾‹
5. **éƒ¨ç½²æŒ‡å—** - å®Œæ•´çš„é›†æˆæ­¥éª¤å’Œæ³¨æ„äº‹é¡¹

é€šè¿‡è¿™äº›æ ¸å¿ƒé€»è¾‘ï¼Œå¯ä»¥å°†å°çº¢ä¹¦è‡ªåŠ¨å…³æ³¨åŠŸèƒ½æ— ç¼é›†æˆåˆ°ä»»ä½•GUIæ¡Œé¢ç¨‹åºä¸­ï¼Œæä¾›ç”¨æˆ·å‹å¥½çš„ç•Œé¢å’Œå¯é çš„è‡ªåŠ¨åŒ–ä½“éªŒã€‚

*æ–‡æ¡£æ›´æ–°æ—¥æœŸ: 2025å¹´1æœˆ13æ—¥*