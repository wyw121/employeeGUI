# å°çº¢ä¹¦è‡ªåŠ¨å…³æ³¨åŠŸèƒ½ - æ™ºèƒ½è®¾å¤‡é€‚é…è§£å†³æ–¹æ¡ˆ

## ğŸ” é—®é¢˜è¯Šæ–­

æ ¹æ®æ‚¨çš„åé¦ˆ"æ¢äº†è®¾å¤‡è¿è¡Œåˆ°æ‰“å¼€å°çº¢ä¹¦ä¾§è¾¹æ ï¼Œç„¶åä¸‹ä¸€æ­¥å°±æ— æ³•æˆåŠŸ"ï¼Œé—®é¢˜æ ¹æºåœ¨äºï¼š

### å½“å‰ç³»ç»Ÿçš„å±€é™æ€§
1. **ç¡¬ç¼–ç åæ ‡ä¾èµ–**ï¼šä½¿ç”¨å›ºå®šåæ ‡å¦‚ `(60, 100)` ç‚¹å‡»å¤´åƒ
2. **ç¼ºä¹å±å¹•é€‚é…**ï¼šä¸åŒè®¾å¤‡åˆ†è¾¨ç‡å¯¼è‡´UIå…ƒç´ ä½ç½®å·®å¼‚
3. **å•ä¸€è¯†åˆ«ç­–ç•¥**ï¼šä¸»è¦ä¾èµ–æ–‡æœ¬åŒ¹é…ï¼Œå®¹æ˜“å¤±è´¥

## ğŸš€ æ™ºèƒ½é€‚é…è§£å†³æ–¹æ¡ˆ

### æ–¹æ¡ˆ1ï¼šåŠ¨æ€å±å¹•é€‚é…ç³»ç»Ÿ

```rust
// æ–°å¢ï¼šæ™ºèƒ½è®¾å¤‡é€‚é…å™¨
pub struct DeviceAdapter {
    device_id: String,
    screen_info: ScreenInfo,
    ui_scale_factor: f32,
    device_profile: DeviceProfile,
}

#[derive(Debug, Clone)]
pub struct ScreenInfo {
    width: u32,
    height: u32,
    density: f32,
    orientation: Orientation,
}

#[derive(Debug, Clone)]
pub struct DeviceProfile {
    brand: String,
    model: String,
    android_version: String,
    xiaohongshu_version: String,
    ui_layout: UILayoutType,
}

#[derive(Debug, Clone)]
pub enum UILayoutType {
    Standard,     // æ ‡å‡†å¸ƒå±€ (1080x1920ç­‰)
    Compact,      // ç´§å‡‘å¸ƒå±€ (å°å±è®¾å¤‡)
    Extended,     // æ‰©å±•å¸ƒå±€ (å¤§å±ã€å¹³æ¿)
    Custom,       // ç‰¹æ®Šè®¾å¤‡å¸ƒå±€
}

impl DeviceAdapter {
    /// åˆ›å»ºæ™ºèƒ½è®¾å¤‡é€‚é…å™¨
    pub async fn new(device_id: String) -> Result<Self> {
        let screen_info = Self::get_screen_info(&device_id).await?;
        let device_profile = Self::get_device_profile(&device_id).await?;
        let ui_scale_factor = Self::calculate_scale_factor(&screen_info);
        
        Ok(Self {
            device_id,
            screen_info,
            ui_scale_factor,
            device_profile,
        })
    }
    
    /// æ™ºèƒ½è®¡ç®—UIå…ƒç´ åæ ‡
    pub fn adapt_coordinates(&self, base_coords: (i32, i32)) -> (i32, i32) {
        let (base_x, base_y) = base_coords;
        
        // åŸºäº1080x1920æ ‡å‡†åˆ†è¾¨ç‡è¿›è¡Œé€‚é…
        let scale_x = self.screen_info.width as f32 / 1080.0;
        let scale_y = self.screen_info.height as f32 / 1920.0;
        
        let adapted_x = (base_x as f32 * scale_x) as i32;
        let adapted_y = (base_y as f32 * scale_y) as i32;
        
        info!("ğŸ”„ åæ ‡é€‚é…: ({},{}) -> ({},{}) (ç¼©æ”¾: {:.2}x{:.2})", 
              base_x, base_y, adapted_x, adapted_y, scale_x, scale_y);
        
        (adapted_x, adapted_y)
    }
    
    /// è·å–è®¾å¤‡å±å¹•ä¿¡æ¯
    async fn get_screen_info(device_id: &str) -> Result<ScreenInfo> {
        // è·å–åˆ†è¾¨ç‡
        let (width, height) = crate::screenshot_service::ScreenshotService::get_screen_resolution(device_id).await?;
        
        // è·å–å±å¹•å¯†åº¦
        let density_output = Self::execute_adb_command(device_id, &[
            "shell", "wm", "density"
        ]).await?;
        
        let density = Self::parse_density_from_output(&density_output)?;
        
        // åˆ¤æ–­å±å¹•æ–¹å‘
        let orientation = if width > height { 
            Orientation::Landscape 
        } else { 
            Orientation::Portrait 
        };
        
        Ok(ScreenInfo {
            width,
            height,
            density,
            orientation,
        })
    }
    
    /// è·å–è®¾å¤‡é…ç½®ä¿¡æ¯
    async fn get_device_profile(device_id: &str) -> Result<DeviceProfile> {
        // è·å–è®¾å¤‡å“ç‰Œå’Œå‹å·
        let brand_output = Self::execute_adb_command(device_id, &[
            "shell", "getprop", "ro.product.brand"
        ]).await?;
        
        let model_output = Self::execute_adb_command(device_id, &[
            "shell", "getprop", "ro.product.model"
        ]).await?;
        
        let android_version_output = Self::execute_adb_command(device_id, &[
            "shell", "getprop", "ro.build.version.release"
        ]).await?;
        
        // è·å–å°çº¢ä¹¦ç‰ˆæœ¬
        let xiaohongshu_version = Self::get_xiaohongshu_version(device_id).await
            .unwrap_or_else(|_| "unknown".to_string());
        
        let brand = brand_output.trim().to_string();
        let model = model_output.trim().to_string();
        let android_version = android_version_output.trim().to_string();
        
        // æ ¹æ®è®¾å¤‡ä¿¡æ¯åˆ¤æ–­UIå¸ƒå±€ç±»å‹
        let ui_layout = Self::determine_ui_layout(&brand, &model, &android_version);
        
        Ok(DeviceProfile {
            brand,
            model,
            android_version,
            xiaohongshu_version,
            ui_layout,
        })
    }
}
```

### æ–¹æ¡ˆ2ï¼šæ™ºèƒ½UIå…ƒç´ å®šä½ç³»ç»Ÿ

```rust
pub struct SmartUILocator {
    adapter: DeviceAdapter,
    adb_path: String,
}

impl SmartUILocator {
    /// æ™ºèƒ½æŸ¥æ‰¾å¤´åƒç‚¹å‡»ä½ç½®
    pub async fn find_avatar_position(&self) -> Result<(i32, i32)> {
        info!("ğŸ¯ å¼€å§‹æ™ºèƒ½å®šä½å¤´åƒä½ç½®...");
        
        // ç­–ç•¥1: åŸºäºUIå…ƒç´ åˆ†æ
        if let Ok(coords) = self.find_avatar_by_ui_analysis().await {
            info!("âœ… é€šè¿‡UIåˆ†ææ‰¾åˆ°å¤´åƒä½ç½®: ({}, {})", coords.0, coords.1);
            return Ok(coords);
        }
        
        // ç­–ç•¥2: åŸºäºè®¾å¤‡é€‚é…çš„å›ºå®šä½ç½®
        let base_coords = self.get_base_avatar_coords();
        let adapted_coords = self.adapter.adapt_coordinates(base_coords);
        
        info!("âœ… ä½¿ç”¨é€‚é…åçš„å¤´åƒä½ç½®: ({}, {})", adapted_coords.0, adapted_coords.1);
        Ok(adapted_coords)
    }
    
    /// é€šè¿‡UIåˆ†ææŸ¥æ‰¾å¤´åƒ
    async fn find_avatar_by_ui_analysis(&self) -> Result<(i32, i32)> {
        let ui_dump = self.get_ui_dump().await?;
        
        // æŸ¥æ‰¾å¤´åƒç›¸å…³çš„UIå…ƒç´ 
        let avatar_selectors = vec![
            "resource-id.*avatar",
            "resource-id.*profile",
            "content-desc.*å¤´åƒ",
            "content-desc.*profile",
            "class.*ImageView.*clickable=\"true\"", // å¯ç‚¹å‡»çš„å¤´åƒå›¾ç‰‡
        ];
        
        for selector in avatar_selectors {
            if let Some(coords) = self.find_element_by_selector(&ui_dump, selector).await? {
                return Ok(coords);
            }
        }
        
        Err(anyhow::anyhow!("æœªæ‰¾åˆ°å¤´åƒå…ƒç´ "))
    }
    
    /// æ™ºèƒ½æŸ¥æ‰¾"å‘ç°å¥½å‹"æŒ‰é’®
    pub async fn find_discover_friends_button(&self) -> Result<(i32, i32)> {
        info!("ğŸ¯ å¼€å§‹æ™ºèƒ½å®šä½å‘ç°å¥½å‹æŒ‰é’®...");
        
        let ui_dump = self.get_ui_dump().await?;
        
        // å¤šç­–ç•¥æŸ¥æ‰¾
        let strategies = vec![
            // ç­–ç•¥1: ç²¾ç¡®æ–‡æœ¬åŒ¹é…
            ("text=\"å‘ç°å¥½å‹\"", "ç²¾ç¡®æ–‡æœ¬åŒ¹é…"),
            ("text.*å‘ç°.*å¥½å‹", "æ¨¡ç³Šæ–‡æœ¬åŒ¹é…"),
            
            // ç­–ç•¥2: èµ„æºIDåŒ¹é…
            ("resource-id.*discover.*friend", "èµ„æºIDåŒ¹é…"),
            ("resource-id.*find.*friend", "èµ„æºIDåŒ¹é…2"),
            
            // ç­–ç•¥3: å†…å®¹æè¿°åŒ¹é…
            ("content-desc.*å‘ç°å¥½å‹", "å†…å®¹æè¿°åŒ¹é…"),
            ("content-desc.*discover.*friend", "å†…å®¹æè¿°è‹±æ–‡åŒ¹é…"),
            
            // ç­–ç•¥4: ç»„åˆæ¡ä»¶åŒ¹é…
            ("clickable=\"true\".*å‘ç°", "å¯ç‚¹å‡»å…ƒç´ +å‘ç°"),
            ("clickable=\"true\".*å¥½å‹", "å¯ç‚¹å‡»å…ƒç´ +å¥½å‹"),
        ];
        
        for (selector, description) in strategies {
            info!("ğŸ” å°è¯•ç­–ç•¥: {}", description);
            if let Some(coords) = self.find_element_by_selector(&ui_dump, selector).await? {
                info!("âœ… é€šè¿‡{}æ‰¾åˆ°æŒ‰é’®ä½ç½®: ({}, {})", description, coords.0, coords.1);
                return Ok(coords);
            }
        }
        
        // å¦‚æœéƒ½æ‰¾ä¸åˆ°ï¼Œä½¿ç”¨é€‚é…åçš„å€™é€‰ä½ç½®
        warn!("âš ï¸ æ™ºèƒ½å®šä½å¤±è´¥ï¼Œä½¿ç”¨é€‚é…å€™é€‰ä½ç½®");
        let candidates = self.get_discover_friends_candidates();
        for candidate in candidates {
            let adapted = self.adapter.adapt_coordinates(candidate);
            // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ ä½ç½®éªŒè¯é€»è¾‘
            return Ok(adapted);
        }
        
        Err(anyhow::anyhow!("æ— æ³•å®šä½å‘ç°å¥½å‹æŒ‰é’®"))
    }
    
    /// åŸºäºæ­£åˆ™è¡¨è¾¾å¼æŸ¥æ‰¾UIå…ƒç´ 
    async fn find_element_by_selector(&self, ui_dump: &str, selector: &str) -> Result<Option<(i32, i32)>> {
        use regex::Regex;
        
        let re = Regex::new(selector)?;
        
        for line in ui_dump.lines() {
            if re.is_match(line) {
                if let Some(bounds) = self.extract_bounds_from_line(line) {
                    let center_x = (bounds.0 + bounds.2) / 2;
                    let center_y = (bounds.1 + bounds.3) / 2;
                    
                    // éªŒè¯åæ ‡åˆç†æ€§
                    if self.is_valid_coordinates(center_x, center_y) {
                        return Ok(Some((center_x, center_y)));
                    }
                }
            }
        }
        
        Ok(None)
    }
    
    /// éªŒè¯åæ ‡æ˜¯å¦åˆç†
    fn is_valid_coordinates(&self, x: i32, y: i32) -> bool {
        let screen_width = self.adapter.screen_info.width as i32;
        let screen_height = self.adapter.screen_info.height as i32;
        
        x > 0 && x < screen_width && y > 0 && y < screen_height
    }
}
```

### æ–¹æ¡ˆ3ï¼šè®¾å¤‡é…ç½®æ–‡ä»¶ç³»ç»Ÿ

```rust
// è®¾å¤‡é…ç½®ç®¡ç†
pub struct DeviceConfigManager {
    configs: HashMap<String, DeviceConfig>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceConfig {
    pub device_key: String,           // è®¾å¤‡æ ‡è¯† (brand_model_resolution)
    pub avatar_coords: (i32, i32),    // å¤´åƒåæ ‡
    pub sidebar_coords: Vec<(i32, i32)>, // ä¾§è¾¹æ æŒ‰é’®åæ ‡
    pub scroll_params: ScrollParams,   // æ»šåŠ¨å‚æ•°
    pub ui_wait_times: WaitTimes,     // ç­‰å¾…æ—¶é—´é…ç½®
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScrollParams {
    pub start_y: i32,
    pub end_y: i32,
    pub duration: u64,
}

impl DeviceConfigManager {
    /// è·å–æˆ–ç”Ÿæˆè®¾å¤‡é…ç½®
    pub async fn get_device_config(&mut self, adapter: &DeviceAdapter) -> Result<DeviceConfig> {
        let device_key = self.generate_device_key(adapter);
        
        if let Some(config) = self.configs.get(&device_key) {
            info!("âœ… æ‰¾åˆ°è®¾å¤‡é…ç½®: {}", device_key);
            return Ok(config.clone());
        }
        
        // å¦‚æœæ²¡æœ‰ç²¾ç¡®åŒ¹é…ï¼Œå°è¯•æŸ¥æ‰¾ç›¸ä¼¼é…ç½®
        if let Some(similar_config) = self.find_similar_config(adapter) {
            info!("ğŸ”„ ä½¿ç”¨ç›¸ä¼¼è®¾å¤‡é…ç½®ï¼Œè¿›è¡Œé€‚é…è°ƒæ•´");
            let adapted_config = self.adapt_config_for_device(similar_config, adapter);
            self.configs.insert(device_key.clone(), adapted_config.clone());
            return Ok(adapted_config);
        }
        
        // ç”Ÿæˆæ–°çš„è®¾å¤‡é…ç½®
        info!("ğŸ†• ç”Ÿæˆæ–°è®¾å¤‡é…ç½®: {}", device_key);
        let new_config = self.generate_default_config(adapter);
        self.configs.insert(device_key.clone(), new_config.clone());
        
        Ok(new_config)
    }
    
    /// å­¦ä¹ å’Œä¼˜åŒ–è®¾å¤‡é…ç½®
    pub async fn learn_from_success(&mut self, device_key: &str, successful_coords: Vec<(String, i32, i32)>) {
        if let Some(config) = self.configs.get_mut(device_key) {
            info!("ğŸ“š å­¦ä¹ æˆåŠŸæ¡ˆä¾‹ï¼Œä¼˜åŒ–è®¾å¤‡é…ç½®");
            
            for (element_type, x, y) in successful_coords {
                match element_type.as_str() {
                    "avatar" => config.avatar_coords = (x, y),
                    "discover_friends" => {
                        // æ›´æ–°ä¾§è¾¹æ åæ ‡
                        if !config.sidebar_coords.contains(&(x, y)) {
                            config.sidebar_coords.insert(0, (x, y));
                        }
                    },
                    _ => {}
                }
            }
            
            // ä¿å­˜é…ç½®åˆ°æ–‡ä»¶
            self.save_configs().await.ok();
        }
    }
}
```

## ğŸ› ï¸ å®æ–½å»ºè®®

### ç«‹å³å¯è¡Œçš„æ”¹è¿›æ–¹æ¡ˆï¼š

1. **æ­¥éª¤1ï¼šæ·»åŠ å±å¹•ä¿¡æ¯è·å–**
```rust
// åœ¨ navigate_to_contacts æ–¹æ³•å¼€å§‹å¤„æ·»åŠ 
let screen_info = self.get_screen_resolution().await?;
info!("ğŸ“± è®¾å¤‡å±å¹•ä¿¡æ¯: {}x{}", screen_info.0, screen_info.1);
```

2. **æ­¥éª¤2ï¼šåæ ‡åŠ¨æ€é€‚é…**
```rust
// æ›¿æ¢ç¡¬ç¼–ç åæ ‡
// æ—§ä»£ç : self.adb_tap(60, 100).await?;
let adapted_coords = self.adapt_coordinates_for_screen((60, 100), screen_info);
self.adb_tap(adapted_coords.0, adapted_coords.1).await?;
```

3. **æ­¥éª¤3ï¼šå¢å¼ºé”™è¯¯è¯Šæ–­**
```rust
// åœ¨æ“ä½œå¤±è´¥æ—¶å¢åŠ è¯Šæ–­ä¿¡æ¯
if let Err(e) = self.adb_tap(x, y).await {
    error!("âŒ ç‚¹å‡»å¤±è´¥: åæ ‡({}, {}) è®¾å¤‡:{}x{} é”™è¯¯:{}", 
           x, y, screen_info.0, screen_info.1, e);
    
    // å°è¯•æˆªå›¾ä¿å­˜ç°åœº
    self.save_debug_screenshot("click_failed").await.ok();
    
    return Err(e);
}
```

### é•¿æœŸä¼˜åŒ–æ–¹æ¡ˆï¼š

1. **å»ºç«‹è®¾å¤‡é…ç½®æ•°æ®åº“**ï¼šæ”¶é›†ä¸åŒè®¾å¤‡çš„æˆåŠŸé…ç½®
2. **å®ç°æœºå™¨å­¦ä¹ é€‚é…**ï¼šåŸºäºæˆåŠŸæ¡ˆä¾‹è‡ªåŠ¨ä¼˜åŒ–åæ ‡
3. **æ·»åŠ å®æ—¶UIåˆ†æ**ï¼šä½¿ç”¨è®¡ç®—æœºè§†è§‰è¯†åˆ«UIå…ƒç´ 

## ğŸ¯ é’ˆå¯¹æ‚¨çš„é—®é¢˜çš„ç›´æ¥è§£å†³æ–¹æ¡ˆ

ç”±äºæ‚¨é‡åˆ°çš„æ˜¯"æ‰“å¼€ä¾§è¾¹æ åä¸‹ä¸€æ­¥æ— æ³•æˆåŠŸ"ï¼Œå»ºè®®ï¼š

1. **ç«‹å³è¯Šæ–­**ï¼šåœ¨ `find_discover_friends_coords` æ–¹æ³•ä¸­æ·»åŠ è¯¦ç»†æ—¥å¿—
2. **åæ ‡éªŒè¯**ï¼šä½¿ç”¨æ‚¨çš„æ–°è®¾å¤‡è·å–å±å¹•åˆ†è¾¨ç‡ï¼Œé‡æ–°è®¡ç®—é€‚é…åæ ‡
3. **UI dumpåˆ†æ**ï¼šåœ¨å¤±è´¥ä½ç½®ä¿å­˜UI dumpï¼Œåˆ†æå®é™…çš„UIç»“æ„

æ‚¨å¸Œæœ›æˆ‘å®ç°è¿™äº›æ”¹è¿›ä¸­çš„å“ªä¸€ä¸ªï¼Ÿæˆ‘å¯ä»¥ä¸ºæ‚¨åˆ›å»ºå…·ä½“çš„ä»£ç ä¿®æ”¹ã€‚